# BTEQ to Snowflake Stored Procedure Conversion

{{ system_prompt }}

## Task
{{ task_description }}

## Input BTEQ Script
```sql
{{ substituted_bteq }}
```

## Target Procedure Name
`{{ procedure_name }}`

{% if reference_deterministic_sp %}
## Reference Implementation (Deterministic)
For comparison, here's a rule-based conversion. You can improve upon this:

```sql
{{ reference_deterministic_sp }}
```
{% endif %}

{% if not reference_deterministic_sp %}
## Token Optimization Active
ðŸª™ **Note**: Deterministic SP reference excluded to optimize prompt size for large BTEQ files.
Focus on applying proven conversion patterns from the examples provided below.
{% endif %}

## Conversion Example Pattern
Here's a concrete example of correct BTEQ-to-Snowflake SP conversion patterns:

### Example 1 - Basic DELETE Pattern:
```sql
.RUN FILE=%%BTEQ_LOGON_SCRIPT%%
.IF ERRORCODE <> 0 THEN .GOTO EXITERR

DELETE BAL
FROM
 %%CAD_PROD_DATA%%.ACCT_BALN_BKDT BAL,
 %%DDSTG%%.ACCT_BALN_BKDT_STG1 STG1
 WHERE 
STG1.ACCT_I = BAL.ACCT_I    
AND STG1.BALN_TYPE_C = BAL.BALN_TYPE_C
AND STG1.CALC_FUNC_C = BAL.CALC_FUNC_C
AND COALESCE(STG1.PROS_KEY_EFFT_I,0) = COALESCE(BAL.PROS_KEY_EFFT_I,0);

.IF ERRORCODE <> 0 THEN .GOTO EXITERR
.QUIT 0
```

### Example 2 - ICEBERG Table Creation Pattern:
```sql
.RUN FILE=%%BTEQ_LOGON_SCRIPT%%

DROP TABLE %%DDSTG%%.WORK_TABLE_1;
CREATE TABLE %%DDSTG%%.WORK_TABLE_1 (
    ACCT_I VARCHAR(255) NOT NULL,
    PATY_I VARCHAR(255) NOT NULL,
    ROW_SECU_ACCS_C INTEGER DEFAULT 0,
    EFFT_D DATE NOT NULL
);

.IF ERRORCODE <> 0 THEN .GOTO EXITERR
.QUIT 0
```

### Example Output SP - DELETE Pattern (CORRECT):
```sql
CREATE OR REPLACE PROCEDURE PS_GDW1_BTEQ.BTEQ_SPS.ACCT_BALN_BKDT_DELT_PROC()
RETURNS STRING
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
  error_code INTEGER DEFAULT 0;
  row_count INTEGER DEFAULT 0;
BEGIN
  -- Convert Teradata DELETE syntax to Snowflake EXISTS pattern
  DELETE FROM PS_CLD_RW.STARCADPRODDATA.ACCT_BALN_BKDT
  WHERE EXISTS (
    SELECT 1 
    FROM PS_CLD_RW.PDDSTG.ACCT_BALN_BKDT_STG1 STG1
    WHERE 
      STG1.ACCT_I = ACCT_BALN_BKDT.ACCT_I    
      AND STG1.BALN_TYPE_C = ACCT_BALN_BKDT.BALN_TYPE_C
      AND STG1.CALC_FUNC_C = ACCT_BALN_BKDT.CALC_FUNC_C
      AND COALESCE(STG1.PROS_KEY_EFFT_I,0) = COALESCE(ACCT_BALN_BKDT.PROS_KEY_EFFT_I,0)
  );
  
  row_count := SQLROWCOUNT;
  RETURN 'SUCCESS: Deleted ' || :row_count || ' records';
EXCEPTION
  WHEN OTHER THEN
    RETURN 'ERROR: ' || SQLERRM || ' (Code: ' || SQLCODE || ')';
END;
$$;
```

### Example Output SP - ICEBERG Table Pattern (CORRECT):
```sql
CREATE OR REPLACE PROCEDURE PS_GDW1_BTEQ.BTEQ_SPS.WORK_TABLE_PROC()
RETURNS STRING
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
  error_code INTEGER DEFAULT 0;
  table_count INTEGER DEFAULT 0;
BEGIN
  -- Drop table with individual error handling
  BEGIN
    DROP ICEBERG TABLE IF EXISTS PS_CLD_RW.PDDSTG.WORK_TABLE_1;
  EXCEPTION
    WHEN OTHER THEN
      NULL; -- Ignore drop errors
  END;

  -- Create ICEBERG table (NO DEFAULT clauses, STRING data types)
  CREATE ICEBERG TABLE PS_CLD_RW.PDDSTG.WORK_TABLE_1 (
    ACCT_I STRING NOT NULL,
    PATY_I STRING NOT NULL,
    ROW_SECU_ACCS_C INTEGER,
    EFFT_D DATE NOT NULL
  );
  
  table_count := table_count + 1;
  RETURN 'SUCCESS: Work tables created. Tables: ' || :table_count;
EXCEPTION
  WHEN OTHER THEN
    RETURN 'FATAL ERROR: ' || SQLERRM || ' (Code: ' || SQLCODE || ')';
END;
$$;
```

## CRITICAL SNOWFLAKE SYNTAX RULES

**ICEBERG Table Syntax (MANDATORY):**
- Table creation: `CREATE ICEBERG TABLE schema.table_name (column STRING NOT NULL)`
- Table dropping: `DROP ICEBERG TABLE IF EXISTS schema.table_name`
- Data types: Use `STRING` instead of `VARCHAR(n)` or `CHAR(n)`
- NO DEFAULT clauses: `ROW_SECU_ACCS_C INTEGER` not `ROW_SECU_ACCS_C INTEGER DEFAULT 0`

**Variable Syntax (MANDATORY):**
- Variable declarations: `variable_name INTEGER DEFAULT 0` (no colon)
- Variable assignments: `variable_name := value` (no colon)  
- Variable references in SQL: `SELECT COUNT(*) INTO :variable_name FROM table`
- Variable references in expressions: `'Result: ' || :variable_name`

**Other Critical Rules:**
- Dollar quoting: Use `$$` not `$DOLLAR$`
- Schema names: `ps_gdw1_bteq.PVTECH` not `PS_CLD_RW.PVTECH`
- Procedure schema: Always `PS_GDW1_BTEQ.BTEQ_SPS.procedure_name`
- File names: Always use lowercase for generated procedure files

{% if analysis_notes %}
## Analysis Notes
{{ analysis_notes }}
{% endif %}

{% if complexity_hints %}
## Complexity Hints
{{ complexity_hints }}
{% endif %}

## Requirements

### Code Quality
{% for requirement in requirements.code_quality %}
- **{{ requirement }}**
{% endfor %}

### BTEQ Pattern Migration
{% for requirement in requirements.bteq_pattern_migration %}
- **{{ requirement }}**
{% endfor %}

### Snowflake Optimization
{% for requirement in requirements.snowflake_optimization %}
- **{{ requirement }}**
{% endfor %}

### ICEBERG Table Requirements
{% for requirement in requirements.iceberg_table_requirements %}
- **{{ requirement }}**
{% endfor %}

### Documentation
{% for requirement in requirements.documentation %}
- **{{ requirement }}**
{% endfor %}

## Output Format
Return a structured JSON response that includes both the stored procedure SQL and metadata about the conversion.

The output should be formatted as a JSON instance that conforms to the JSON schema below.

**CRITICAL**: Return ONLY valid JSON. No explanations, no markdown formatting, no additional text.

JSON Schema:
```json
{
  "procedure_name": "string (procedure name ending with _PROC)",
  "sql_code": "string (complete Snowflake stored procedure SQL)",
  "purpose": "string (brief business purpose description)",
  "parameters": ["array of strings (parameter descriptions)"],
  "business_logic": ["array of strings (key business logic points)"],
  "error_handling": ["array of strings (error handling patterns)"],
  "bteq_features_converted": ["array of strings (BTEQ features converted)"],
  "snowflake_enhancements": ["array of strings (Snowflake-specific improvements)"],
  "migration_notes": ["array of strings (optional conversion notes)"],
  "performance_considerations": ["array of strings (optional performance notes)"]
}
```

## JSON Response:
