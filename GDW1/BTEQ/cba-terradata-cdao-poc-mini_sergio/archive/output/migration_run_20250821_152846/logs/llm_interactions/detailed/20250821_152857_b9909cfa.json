{
  "interaction_id": "20250821_152857_b9909cfa",
  "timestamp": "2025-08-21T15:28:57.107595",
  "provider": "snowflake_cortex",
  "model": "claude-4-sonnet",
  "request_type": "dbt_conversion",
  "prompt": "# BTEQ SQL to DBT Model Conversion\n\nYou are a senior data engineer expert in converting legacy BTEQ SQL scripts to modern DBT models with Jinja templating.\n\n## CRITICAL INSTRUCTIONS - NO HALLUCINATION POLICY\n- ONLY transform the logic provided in the source BTEQ SQL\n- DO NOT add new business logic, columns, or transformations\n- DO NOT create new table references not in the original\n- PRESERVE all existing business logic exactly\n- If unclear about any logic, maintain the original approach\n\n## Source Context\n\n### 1. Original BTEQ SQL Script\n```sql\n.RUN FILE=%%BTEQ_LOGON_SCRIPT%%\n.IF ERRORCODE <> 0 THEN .GOTO EXITERR\n\n.SET QUIET OFF\n.SET ECHOREQ ON\n.SET FORMAT OFF\n.SET WIDTH 120\n\n------------------------------------------------------------------------------\n--  SCRIPT NAME: 90_ISRT_ACCT_BALN_BKDT_ADJ_RULE\n--Description: Calculate the Backdated adjustment from ACCT BALN ADJ and apply \n--it on ACCT BALN\n--\n--  Ver  Date       Modified By        \t\t    Description\n--  ---- ---------- ---------------------------------------------------------\n--  1.0  22/07/2011 Suresh Vajapeyajula        \tInitial Version\n\n-- $LastChangedBy: vajapes $\n-- $LastChangedDate: 2012-02-28 09:08:17 +1100 (Tue, 28 Feb 2012) $\n-- $LastChangedRevision: 9216 $\n\n------------------------------------------------------------------------------\n\n\nDELETE %%DDSTG%%.ACCT_BALN_BKDT_ADJ_RULE;\n\n.IF ERRORCODE <> 0 THEN .GOTO EXITERR\n\nINSERT INTO %%DDSTG%%.ACCT_BALN_BKDT_ADJ_RULE\n(\nACCT_I, \nSRCE_SYST_C,\nBALN_TYPE_C,\nCALC_FUNC_C,\nTIME_PERD_C,\nADJ_FROM_D,\nBKDT_ADJ_FROM_D,\nADJ_TO_D,\nADJ_A,\nEFFT_D,\nGl_RECN_F,\nPROS_KEY_EFFT_I               \n)\nSELECT \nDT1.ACCT_I,\nDT1.SRCE_SYST_C, \nDT1.BALN_TYPE_C,\nDT1.CALC_FUNC_C,\nDT1.TIME_PERD_C,\nDT1.ADJ_FROM_D,\nCASE WHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4))  = 0 \nTHEN DT1.ADJ_FROM_D \n/*Backdated logic calculation when diffrence of months is 1 \nand DT1.EFFT_D is between Business day 1 and Biz day 4*/\nWHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4))  = 1 \nAND DT1.EFFT_D <= BSDY_4.CALR_CALR_D THEN DT1.ADJ_FROM_D\n\n/*Backdated logic calculation when diffrence of months is 1 \nand DT1.EFFT_D is NOT between Business day 1 and Biz day 4*/\nWHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4)) = 1 \nAND DT1.EFFT_D > BSDY_4.CALR_CALR_D  THEN  DT1.EFFT_D - (EXTRACT (DAY FROM DT1.EFFT_D) - 1)  \n\n/*Backdated logic calculation when diffrence of months is greater than 1 \nand DT1.EFFT_D is between Business day 1 and Biz day 4*/\nWHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4))> 1 \nAND DT1.EFFT_D <= BSDY_4.CALR_CALR_D \nTHEN DT1.EFFT_D - (EXTRACT (DAY FROM DT1.EFFT_D) - 1)-INTERVAL '1' MONTH\n\n/*Backdated logic calculation when diffrence of months is greater than 1 \nand DT1.EFFT_D is  NOT between Business day 1 and Biz day 4*/\nWHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4))  > 1 \nAND DT1.EFFT_D > BSDY_4.CALR_CALR_D  THEN DT1.EFFT_D - (EXTRACT (DAY FROM DT1.EFFT_D) - 1) \nEND AS BKDT_ADJ_FROM_D,\nDT1.ADJ_TO_D,\n/*Similar adjustments for the same period are added */\nSUM(DT1.ADJ_A) AS ADJ_A,\nDT1.EFFT_D,\nDT1.Gl_RECN_F,\nDT1.PROS_KEY_EFFT_I\nFROM\n(\nSELECT\t\nADJ.ACCT_I AS ACCT_I,\nADJ.SRCE_SYST_C AS SRCE_SYST_C, \nADJ.BALN_TYPE_C AS BALN_TYPE_C,\nADJ.CALC_FUNC_C AS CALC_FUNC_C,\nADJ.TIME_PERD_C AS TIME_PERD_C,\nADJ.ADJ_FROM_D AS ADJ_FROM_D,\nADJ.ADJ_TO_D,\n/*Adjustments impacting the current record need to be loaded on the next day to avoid changing the open balances\n*/\n(CASE WHEN ADJ.EFFT_D = ADJ.ADJ_TO_D THEN EFFT_D+1\nELSE EFFT_D END) AS EFFT_D,\nADJ.Gl_RECN_F,\nADJ_A,\nPROS_KEY_EFFT_I\nFROM\n%%VTECH%%.ACCT_BALN_ADJ  ADJ\nWHERE\t\nSRCE_SYST_C = 'SAP'\nAND BALN_TYPE_C='BALN'\nAND CALC_FUNC_C='SPOT' \nAND TIME_PERD_C = 'E' \n/*Excluding the adjustments  with $0 in value as this brings no change to the \n$value in tha ACCT BALN and had a negative impact on the last records in \nACCT BALN, so considerably important to eliminate*/\nAND ADJ.ADJ_A <> 0 \n/* Capturing delta adjustments*/\nAND ADJ.EFFT_D >= \n\t(SELECT MAX(BTCH_RUN_D) \n\tFROM %%VTECH%%.UTIL_PROS_ISAC \n\tWHERE    TRGT_M='ACCT_BALN_BKDT' AND SRCE_SYST_M='GDW'\n\tAND COMT_F = 'Y'  \tAND SUCC_F='Y')\n)DT1\nINNER JOIN\n(\n/*Calulation of Business day 4 Logic*/\nSELECT\t\nCALR_YEAR_N,\nCALR_MNTH_N,\nCALR_CALR_D\nFROM\t\n%%VTECH%%.GRD_RPRT_CALR_CLYR\nWHERE\t\nCALR_WEEK_DAY_N NOT IN (1,7) \nAND CALR_NON_WORK_DAY_F = 'N'\nAND CALR_CALR_D BETWEEN  ADD_MONTHS(CURRENT_DATE,-13) AND ADD_MONTHS(CURRENT_DATE,+1)\nQUALIFY\tROW_NUMBER() OVER (PARTITION BY CALR_YEAR_N, CALR_MNTH_N \nORDER\tBY CALR_CALR_D) = 4\n)BSDY_4\nON EXTRACT (YEAR \nFROM DT1.EFFT_D)=EXTRACT (YEAR FROM BSDY_4.CALR_CALR_D)\nAND EXTRACT (MONTH FROM DT1.EFFT_D)=EXTRACT (MONTH FROM BSDY_4.CALR_CALR_D)\n\nWHERE\n/*Including the adjustments that are excluded  in the previous run  for open record*/\nDT1.EFFT_D <= (SELECT MAX(BTCH_RUN_D) AS BTCH_RUN_D\nFROM %%VTECH%%.UTIL_PROS_ISAC\nWHERE    TRGT_M='ACCT_BALN_ADJ' AND SRCE_SYST_M='SAP'\nAND COMT_F = 'Y'  AND SUCC_F='Y')\n\n/*To avoid any records that are processed in the previous runs */\nAND  DT1.EFFT_D > (SELECT MAX(BTCH_RUN_D) AS BTCH_RUN_D\nFROM %%VTECH%%.UTIL_PROS_ISAC\nWHERE    \nTRGT_M='ACCT_BALN_BKDT' AND SRCE_SYST_M='GDW'\nAND COMT_F = 'Y'  AND SUCC_F='Y')\n\n/*To exclude any adjustments that fall in the period where the GL is closed*/\nAND BKDT_ADJ_FROM_D <= ADJ_TO_D\n\nGROUP BY ACCT_I,SRCE_SYST_C, BALN_TYPE_C ,CALC_FUNC_C,TIME_PERD_C,ADJ_FROM_D,\nBKDT_ADJ_FROM_D,ADJ_TO_D,EFFT_D,Gl_RECN_F, PROS_KEY_EFFT_I;\n\n\n.IF ERRORCODE <> 0 THEN .GOTO EXITERR\n\n.QUIT 0\n.LOGOFF\n\n.LABEL EXITERR\n.QUIT 1\n.LOGOFF\n.EXIT\n```\n\n### 2. Reference Stored Procedure Translation (for context)\n```sql\nCREATE OR REPLACE PROCEDURE ACCT_BALN_BKDT_ADJ_RULE_ISRT\n(\n    ERROR_TABLE STRING DEFAULT 'PROCESS_ERROR_LOG',\n    PROCESS_KEY STRING DEFAULT 'UNKNOWN_PROCESS'\n  )\n  RETURNS STRING\n  LANGUAGE SQL\n  EXECUTE AS CALLER\nAS\n$$\nDECLARE\n-- =============================================================================\n-- Procedure: ACCT_BALN_BKDT_ADJ_RULE_ISRT\n-- Generated: 2025-08-21 15:28:57\n-- Source: Converted from Teradata BTEQ script\n-- Generator: SnowflakeSPGenerator v1.0\n-- =============================================================================\n-- Original BTEQ Preview:\n-- .RUN FILE=%%BTEQ_LOGON_SCRIPT%%\n-- .IF ERRORCODE <> 0 THEN .GOTO EXITERR\n-- \n-- .SET QUIET OFF\n-- .SET ECHOREQ ON\n-- .SET FORMAT OFF\n-- .SET WIDTH 120\n-- \n-- ------------------------------------------------------------------------------\n-- --  SCRIPT NAME: 90_ISRT_ACCT_BALN_BKDT_ADJ_RULE\n-- =============================================================================\n\n  -- Variable declarations\n  LET error_code INTEGER DEFAULT 0;\n  LET sql_state STRING DEFAULT '00000';\n  LET error_message STRING DEFAULT '';\n  LET row_count INTEGER DEFAULT 0;\n  LET current_step STRING DEFAULT 'INIT';\n\n  -- Label tracking variables\n  LET goto_exiterr BOOLEAN DEFAULT FALSE;\n\n  -- Exception handling setup\n  DECLARE\n    general_exception EXCEPTION (-20001, 'General procedure error');\n  BEGIN\n    -- Main procedure logic starts here\n\n    -- Line 1: .RUN FILE=%%BTEQ_LOGON_SCRIPT%%\n    -- RUN statement: Execute accumulated SQL\n    -- (SQL execution handled inline in Snowflake)\n\n    -- Line 2: .IF ERRORCODE <> 0 THEN .GOTO EXITERR\n    IF (error_code <> 0) THEN\n      GOTO error_exit;\n    END IF;\n\n    -- SQL Block (lines 25-26)\n    current_step := 'EXECUTING_SQL';\n    BEGIN\n      DELETE PDDSTG.ACCT_BALN_BKDT_ADJ_RULE;\n      ;\n      -- Get row count and check for errors\n      row_count := SQLROWCOUNT;\n      IF (SQLCODE <> 0) THEN\n        error_code := SQLCODE;\n        error_message := SQLERRM;\n        GOTO error_exit;\n      END IF;\n    EXCEPTION\n      WHEN OTHER THEN\n        error_code := SQLCODE;\n        error_message := SQLERRM;\n        GOTO error_exit;\n    END;\n\n    -- Line 27: .IF ERRORCODE <> 0 THEN .GOTO EXITERR\n    IF (error_code <> 0) THEN\n      GOTO error_exit;\n    END IF;\n\n    -- SQL Block (lines 29-155)\n    current_step := 'EXECUTING_SQL';\n    BEGIN\n      INSERT INTO PDDSTG.ACCT_BALN_BKDT_ADJ_RULE\n      (\n      ACCT_I, \n      SRCE_SYST_C,\n      BALN_TYPE_C,\n      CALC_FUNC_C,\n      TIME_PERD_C,\n      ADJ_FROM_D,\n      BKDT_ADJ_FROM_D,\n      ADJ_TO_D,\n      ADJ_A,\n      EFFT_D,\n      Gl_RECN_F,\n      PROS_KEY_EFFT_I               \n      )\n      SELECT \n      DT1.ACCT_I,\n      DT1.SRCE_SYST_C, \n      DT1.BALN_TYPE_C,\n      DT1.CALC_FUNC_C,\n      DT1.TIME_PERD_C,\n      DT1.ADJ_FROM_D,\n      CASE WHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4))  = 0 \n      THEN DT1.ADJ_FROM_D \n      /*Backdated logic calculation when diffrence of months is 1 \n      and DT1.EFFT_D is between Business day 1 and Biz day 4*/\n      WHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4))  = 1 \n      AND DT1.EFFT_D <= BSDY_4.CALR_CALR_D THEN DT1.ADJ_FROM_D\n      /*Backdated logic calculation when diffrence of months is 1 \n      and DT1.EFFT_D is NOT between Business day 1 and Biz day 4*/\n      WHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4)) = 1 \n      AND DT1.EFFT_D > BSDY_4.CALR_CALR_D  THEN  DT1.EFFT_D - (EXTRACT (DAY FROM DT1.EFFT_D) - 1)  \n      /*Backdated logic calculation when diffrence of months is greater than 1 \n      and DT1.EFFT_D is between Business day 1 and Biz day 4*/\n      WHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4))> 1 \n      AND DT1.EFFT_D <= BSDY_4.CALR_CALR_D \n      THEN DT1.EFFT_D - (EXTRACT (DAY FROM DT1.EFFT_D) - 1)-INTERVAL '1' MONTH\n      /*Backdated logic calculation when diffrence of months is greater than 1 \n      and DT1.EFFT_D is  NOT between Business day 1 and Biz day 4*/\n      WHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4))  > 1 \n      AND DT1.EFFT_D > BSDY_4.CALR_CALR_D  THEN DT1.EFFT_D - (EXTRACT (DAY FROM DT1.EFFT_D) - 1) \n      END AS BKDT_ADJ_FROM_D,\n      DT1.ADJ_TO_D,\n      /*Similar adjustments for the same period are added */\n      SUM(DT1.ADJ_A) AS ADJ_A,\n      DT1.EFFT_D,\n      DT1.Gl_RECN_F,\n      DT1.PROS_KEY_EFFT_I\n      FROM\n      (\n      SELECT\t\n      ADJ.ACCT_I AS ACCT_I,\n      ADJ.SRCE_SYST_C AS SRCE_SYST_C, \n      ADJ.BALN_TYPE_C AS BALN_TYPE_C,\n      ADJ.CALC_FUNC_C AS CALC_FUNC_C,\n      ADJ.TIME_PERD_C AS TIME_PERD_C,\n      ADJ.ADJ_FROM_D AS ADJ_FROM_D,\n      ADJ.ADJ_TO_D,\n      /*Adjustments impacting the current record need to be loaded on the next day to avoid changing the open balances\n      */\n      (CASE WHEN ADJ.EFFT_D = ADJ.ADJ_TO_D THEN EFFT_D+1\n      ELSE EFFT_D END) AS EFFT_D,\n      ADJ.Gl_RECN_F,\n      ADJ_A,\n      PROS_KEY_EFFT_I\n      FROM\n      PVTECH.ACCT_BALN_ADJ  ADJ\n      WHERE\t\n      SRCE_SYST_C = 'SAP'\n      AND BALN_TYPE_C='BALN'\n      AND CALC_FUNC_C='SPOT' \n      AND TIME_PERD_C = 'E' \n      /*Excluding the adjustments  with $0 in value as this brings no change to the \n      $value in tha ACCT BALN and had a negative impact on the last records in \n      ACCT BALN, so considerably important to eliminate*/\n      AND ADJ.ADJ_A <> 0 \n      /* Capturing delta adjustments*/\n      AND ADJ.EFFT_D >= \n      \t(SELECT MAX(BTCH_RUN_D) \n      \tFROM PVTECH.UTIL_PROS_ISAC \n      \tWHERE    TRGT_M='ACCT_BALN_BKDT' AND SRCE_SYST_M='GDW'\n      \tAND COMT_F = 'Y'  \tAND SUCC_F='Y')\n      )DT1\n      INNER JOIN\n      (\n      /*Calulation of Business day 4 Logic*/\n      SELECT\t\n      CALR_YEAR_N,\n      CALR_MNTH_N,\n      CALR_CALR_D\n      FROM\t\n      PVTECH.GRD_RPRT_CALR_CLYR\n      WHERE\t\n      CALR_WEEK_DAY_N NOT IN (1,7) \n      AND CALR_NON_WORK_DAY_F = 'N'\n      AND CALR_CALR_D BETWEEN  ADD_MONTHS(CURRENT_DATE,-13) AND ADD_MONTHS(CURRENT_DATE,+1)\n      QUALIFY\tROW_NUMBER() OVER (PARTITION BY CALR_YEAR_N, CALR_MNTH_N \n      ORDER\tBY CALR_CALR_D) = 4\n      )BSDY_4\n      ON EXTRACT (YEAR \n      FROM DT1.EFFT_D)=EXTRACT (YEAR FROM BSDY_4.CALR_CALR_D)\n      AND EXTRACT (MONTH FROM DT1.EFFT_D)=EXTRACT (MONTH FROM BSDY_4.CALR_CALR_D)\n      WHERE\n      /*Including the adjustments that are excluded  in the previous run  for open record*/\n      DT1.EFFT_D <= (SELECT MAX(BTCH_RUN_D) AS BTCH_RUN_D\n      FROM PVTECH.UTIL_PROS_ISAC\n      WHERE    TRGT_M='ACCT_BALN_ADJ' AND SRCE_SYST_M='SAP'\n      AND COMT_F = 'Y'  AND SUCC_F='Y')\n      /*To avoid any records that are processed in the previous runs */\n      AND  DT1.EFFT_D > (SELECT MAX(BTCH_RUN_D) AS BTCH_RUN_D\n      FROM PVTECH.UTIL_PROS_ISAC\n      WHERE    \n      TRGT_M='ACCT_BALN_BKDT' AND SRCE_SYST_M='GDW'\n      AND COMT_F = 'Y'  AND SUCC_F='Y')\n      /*To exclude any adjustments that fall in the period where the GL is closed*/\n      AND BKDT_ADJ_FROM_D <= ADJ_TO_D\n      GROUP BY ACCT_I,SRCE_SYST_C, BALN_TYPE_C ,CALC_FUNC_C,TIME_PERD_C,ADJ_FROM_D,\n      BKDT_ADJ_FROM_D,ADJ_TO_D,EFFT_D,Gl_RECN_F, PROS_KEY_EFFT_I;\n      ;\n      -- Get row count and check for errors\n      row_count := SQLROWCOUNT;\n      IF (SQLCODE <> 0) THEN\n        error_code := SQLCODE;\n        error_message := SQLERRM;\n        GOTO error_exit;\n      END IF;\n    EXCEPTION\n      WHEN OTHER THEN\n        error_code := SQLCODE;\n        error_message := SQLERRM;\n        GOTO error_exit;\n    END;\n\n    -- Line 156: .IF ERRORCODE <> 0 THEN .GOTO EXITERR\n    IF (error_code <> 0) THEN\n      GOTO error_exit;\n    END IF;\n\n    -- Line 159: .LOGOFF\n    -- LOGOFF: Connection cleanup handled by Snowflake\n    current_step := 'LOGOFF_COMPLETED';\n\n    -- Line 161: .LABEL EXITERR\n    exiterr:\n\n    -- Line 163: .LOGOFF\n    -- LOGOFF: Connection cleanup handled by Snowflake\n    current_step := 'LOGOFF_COMPLETED';\n\n    -- Success path\n    RETURN 'SUCCESS: ' || current_step || ' completed. Rows processed: ' || row_count;\n\n    -- Error handling\n    error_exit:\n      -- Log error to error table if available\n      INSERT INTO IDENTIFIER(:ERROR_TABLE) (PROCESS_KEY, ERROR_CODE, ERROR_MESSAGE, ERROR_TIMESTAMP)\n      VALUES (:PROCESS_KEY, error_code, error_message, CURRENT_TIMESTAMP());\n      \n      RETURN 'ERROR: ' || error_message || ' (Code: ' || error_code || ')';\n\n  EXCEPTION\n    WHEN OTHER THEN\n      RETURN 'FATAL ERROR: ' || SQLERRM || ' (Code: ' || SQLCODE || ')';\nEND;\n$$;\n```\n\n### 3. Additional Analysis\nBTEQ to DBT conversion for ACCT_BALN_BKDT_ADJ_RULE_ISRT\n\n\n## DBT Conversion Requirements\n\n### 1. DBT Model Structure\n- Start with proper Jinja config block using config() macro\n- Use appropriate materialization strategy (table, view, incremental)\n- Add meaningful tags for categorization\n- Include pre_hook and post_hook for logging if needed\n- Set proper database/schema references using vars\n\n### 2. SQL Best Practices\n- Use modern SQL patterns (CTEs over subqueries where beneficial)\n- Implement proper column naming and aliasing\n- Add clear comments explaining business logic\n- Use explicit column lists (avoid SELECT *)\n- Optimize JOIN patterns and WHERE clause ordering\n\n### 3. DBT-Specific Features\n- Use ref() macro for model dependencies\n- Use var() macro for configuration values\n- Use source() macro if referencing source tables\n- Add data quality tests where appropriate\n- Use DBT's built-in functions for date/time operations\n\n### 4. Materialization Strategy\n- Choose appropriate materialization based on table usage:\n  * `table` for frequently queried data\n  * `view` for lightweight transformations\n  * `incremental` for large datasets with delta processing\n- Include incremental_strategy if using incremental\n\n### 5. Configuration Best Practices\n- Use meaningful database/schema configuration\n- Add appropriate tags for data lineage\n- Include pre/post hooks for process logging\n- Set up proper error handling in hooks\n\n### 6. Code Organization\n- Use clear CTE naming that describes the transformation\n- Group related logic into logical CTEs\n- Add section comments for major transformations\n- Maintain proper indentation and formatting\n\n## Expected DBT Model Output Format\n\nThe output should be a complete DBT model file with:\n\n```sql\n{%- set process_name = 'YOUR_PROCESS_NAME' -%}\n{%- set stream_name = 'YOUR_STREAM_NAME' -%}\n\n{{\n  config(\n    materialized='your_strategy',\n    database=var('target_database'),\n    schema='target_schema',\n    tags=['relevant', 'tags'],\n    pre_hook=[\n        \"{{ log_dcf_exec_msg('Process started') }}\"\n    ],\n    post_hook=[\n        \"{{ log_dcf_exec_msg('Process ended') }}\"\n    ]\n  )\n}}\n\n/*\n    Model Documentation\n    Purpose: Brief description\n    Business Logic: Key transformations\n    Dependencies: Source tables/models\n*/\n\nWITH cte_name AS (\n    -- Clear CTE logic\n    SELECT ...\n),\n\nfinal AS (\n    SELECT ...\n)\n\nSELECT * FROM final\n```\n\n## Specific Transformation Guidance\n\n### BTEQ Control Flow → DBT Patterns\n- Convert DELETE + INSERT patterns to proper materialization\n- Replace BTEQ variables with DBT vars and Jinja variables\n- Transform error handling to DBT test patterns where possible\n- Convert procedural logic to declarative SQL transformations\n\n### Date/Time Functions\n- Use DBT date functions or modern SQL equivalents\n- Replace Teradata date arithmetic with standard functions\n- Maintain timezone handling if present\n\n### Process Control Tables\n- Reference process control via source() or ref() macros\n- Use var() for process configuration values\n- Implement delta processing via incremental materialization\n\n## Output Instructions\n\nProvide ONLY the complete DBT model SQL code. Do not include explanations, markdown formatting, or additional commentary.\n\n## DBT Model:",
  "prompt_length": 17333,
  "prompt_hash": "b9909cfa3bdfeea947db2ddae4beb750",
  "temperature": null,
  "max_tokens": null,
  "response": "```sql\n{%- set process_name = 'ACCT_BALN_BKDT_ADJ_RULE' -%}\n{%- set stream_name = 'ACCT_BALN_BKDT' -%}\n\n{{\n  config(\n    materialized='table',\n    database=var('target_database'),\n    schema='ddstg',\n    tags=['account_balance', 'backdated_adjustment', 'sap'],\n    pre_hook=[\n        \"DELETE FROM {{ this }}\",\n        \"{{ log_dcf_exec_msg('ACCT_BALN_BKDT_ADJ_RULE process started') }}\"\n    ],\n    post_hook=[\n        \"{{ log_dcf_exec_msg('ACCT_BALN_BKDT_ADJ_RULE process ended') }}\"\n    ]\n  )\n}}\n\n/*\n    Model: ACCT_BALN_BKDT_ADJ_RULE\n    Purpose: Calculate the Backdated adjustment from ACCT BALN ADJ and apply it on ACCT BALN\n    Business Logic: \n    - Processes SAP account balance adjustments with backdating logic\n    - Calculates business day 4 logic for adjustment timing\n    - Aggregates similar adjustments for the same period\n    Dependencies: \n    - {{ ref('acct_baln_adj') }}\n    - {{ ref('grd_rprt_calr_clyr') }}\n    - {{ ref('util_pros_isac') }}\n*/\n\nWITH acct_baln_adj_filtered AS (\n    SELECT\t\n        ADJ.ACCT_I AS ACCT_I,\n        ADJ.SRCE_SYST_C AS SRCE_SYST_C, \n        ADJ.BALN_TYPE_C AS BALN_TYPE_C,\n        ADJ.CALC_FUNC_C AS CALC_FUNC_C,\n        ADJ.TIME_PERD_C AS TIME_PERD_C,\n        ADJ.ADJ_FROM_D AS ADJ_FROM_D,\n        ADJ.ADJ_TO_D,\n        -- Adjustments impacting the current record need to be loaded on the next day to avoid changing the open balances\n        CASE \n            WHEN ADJ.EFFT_D = ADJ.ADJ_TO_D THEN DATEADD(DAY, 1, ADJ.EFFT_D)\n            ELSE ADJ.EFFT_D \n        END AS EFFT_D,\n        ADJ.GL_RECN_F,\n        ADJ.ADJ_A,\n        ADJ.PROS_KEY_EFFT_I\n    FROM {{ ref('acct_baln_adj') }} ADJ\n    WHERE\t\n        ADJ.SRCE_SYST_C = 'SAP'\n        AND ADJ.BALN_TYPE_C = 'BALN'\n        AND ADJ.CALC_FUNC_C = 'SPOT' \n        AND ADJ.TIME_PERD_C = 'E' \n        -- Excluding the adjustments with $0 in value as this brings no change to the \n        -- $value in tha ACCT BALN and had a negative impact on the last records in \n        -- ACCT BALN, so considerably important to eliminate\n        AND ADJ.ADJ_A <> 0 \n        -- Capturing delta adjustments\n        AND ADJ.EFFT_D >= (\n            SELECT MAX(BTCH_RUN_D) \n            FROM {{ ref('util_pros_isac') }}\n            WHERE TRGT_M = 'ACCT_BALN_BKDT' \n                AND SRCE_SYST_M = 'GDW'\n                AND COMT_F = 'Y'  \t\n                AND SUCC_F = 'Y'\n        )\n),\n\nbusiness_day_4 AS (\n    -- Calculation of Business day 4 Logic\n    SELECT\t\n        CALR_YEAR_N,\n        CALR_MNTH_N,\n        CALR_CALR_D\n    FROM {{ ref('grd_rprt_calr_clyr') }}\n    WHERE\t\n        CALR_WEEK_DAY_N NOT IN (1, 7) \n        AND CALR_NON_WORK_DAY_F = 'N'\n        AND CALR_CALR_D BETWEEN DATEADD(MONTH, -13, CURRENT_DATE()) AND DATEADD(MONTH, 1, CURRENT_DATE())\n    QUALIFY\tROW_NUMBER() OVER (\n        PARTITION BY CALR_YEAR_N, CALR_MNTH_N \n        ORDER BY CALR_CALR_D\n    ) = 4\n),\n\ndt1_with_business_day AS (\n    SELECT \n        DT1.ACCT_I,\n        DT1.SRCE_SYST_C, \n        DT1.BALN_TYPE_C,\n        DT1.CALC_FUNC_C,\n        DT1.TIME_PERD_C,\n        DT1.ADJ_FROM_D,\n        DT1.ADJ_TO_D,\n        DT1.EFFT_D,\n        DT1.GL_RECN_F,\n        DT1.ADJ_A,\n        DT1.PROS_KEY_EFFT_I,\n        BSDY_4.CALR_CALR_D AS BUSINESS_DAY_4,\n        DATEDIFF(MONTH, DT1.ADJ_FROM_D, DT1.EFFT_D) AS MONTH_DIFF\n    FROM acct_baln_adj_filtered DT1\n    INNER JOIN business_day_4 BSDY_4\n        ON EXTRACT(YEAR FROM DT1.EFFT_D) = EXTRACT(YEAR FROM BSDY_4.CALR_CALR_D)\n        AND EXTRACT(MONTH FROM DT1.EFFT_D) = EXTRACT(MONTH FROM BSDY_4.CALR_CALR_D)\n),\n\nfinal AS (\n    SELECT \n        DT1.ACCT_I,\n        DT1.SRCE_SYST_C, \n        DT1.BALN_TYPE_C,\n        DT1.CALC_FUNC_C,\n        DT1.TIME_PERD_C,\n        DT1.ADJ_FROM_D,\n        CASE \n            WHEN DT1.MONTH_DIFF = 0 \n                THEN DT1.ADJ_FROM_D \n            -- Backdated logic calculation when difference of months is 1 \n            -- and DT1.EFFT_D is between Business day 1 and Biz day 4\n            WHEN DT1.MONTH_DIFF = 1 \n                AND DT1.EFFT_D <= DT1.BUSINESS_DAY_4 \n                THEN DT1.ADJ_FROM_D\n            -- Backdated logic calculation when difference of months is 1 \n            -- and DT1.EFFT_D is NOT between Business day 1 and Biz day 4\n            WHEN DT1.MONTH_DIFF = 1 \n                AND DT1.EFFT_D > DT1.BUSINESS_DAY_4  \n                THEN DATE_TRUNC('MONTH', DT1.EFFT_D)\n            -- Backdated logic calculation when difference of months is greater than 1 \n            -- and DT1.EFFT_D is between Business day 1 and Biz day 4\n            WHEN DT1.MONTH_DIFF > 1 \n                AND DT1.EFFT_D <= DT1.BUSINESS_DAY_4 \n                THEN DATEADD(MONTH, -1, DATE_TRUNC('MONTH', DT1.EFFT_D))\n            -- Backdated logic calculation when difference of months is greater than 1 \n            -- and DT1.EFFT_D is NOT between Business day 1 and Biz day 4\n            WHEN DT1.MONTH_DIFF > 1 \n                AND DT1.EFFT_D > DT1.BUSINESS_DAY_4  \n                THEN DATE_TRUNC('MONTH', DT1.EFFT_D)\n        END AS BKDT_ADJ_FROM_D,\n        DT1.ADJ_TO_D,\n        -- Similar adjustments for the same period are added\n        SUM(DT1.ADJ_A) AS ADJ_A,\n        DT1.EFFT_D,\n        DT1.GL_RECN_F,\n        DT1.PROS_KEY_EFFT_I\n    FROM dt1_with_business_day DT1\n    WHERE\n        -- Including the adjustments that are excluded in the previous run for open record\n        DT1.EFFT_D <= (\n            SELECT MAX(BTCH_RUN_D) AS BTCH_RUN_D\n            FROM {{ ref('util_pros_isac') }}\n            WHERE TRGT_M = 'ACCT_BALN_ADJ' \n                AND SRCE_SYST_M = 'SAP'\n                AND COMT_F = 'Y'  \n                AND SUCC_F = 'Y'\n        )\n        -- To avoid any records that are processed in the previous runs\n        AND DT1.EFFT_D > (\n            SELECT MAX(BTCH_RUN_D) AS BTCH_RUN_D\n            FROM {{ ref('util_pros_isac') }}\n            WHERE TRGT_M = 'ACCT_BALN_BKDT' \n                AND SRCE_SYST_M = 'GDW'\n                AND COMT_F = 'Y'  \n                AND SUCC_F = 'Y'\n        )\n    GROUP BY \n        DT1.ACCT_I,\n        DT1.SRCE_SYST_C, \n        DT1.BALN_TYPE_C,\n        DT1.CALC_FUNC_C,\n        DT1.TIME_PERD_C,\n        DT1.ADJ_FROM_D,\n        BKDT_ADJ_FROM_D,\n        DT1.ADJ_TO_D,\n        DT1.EFFT_D,\n        DT1.GL_RECN_F, \n        DT1.PROS_KEY_EFFT_I\n    HAVING \n        -- To exclude any adjustments that fall in the period where the GL is closed\n        BKDT_ADJ_FROM_D <= DT1.ADJ_TO_D\n)\n\nSELECT * FROM final\n```",
  "response_length": 6390,
  "response_hash": "a9c93813531570728b82537d84a9a82f",
  "context_data": {
    "procedure_name": "ACCT_BALN_BKDT_ADJ_RULE_ISRT",
    "conversion_type": "bteq_to_dbt"
  },
  "processing_time_ms": 59153,
  "success": true,
  "error_message": null,
  "quality_score": null,
  "enhancements_detected": null
}