# LLM RESPONSE
Interaction ID: edd1dc2e
Conversion Type: bteq2sp
Procedure: ACCT_BALN_BKDT_ADJ_RULE_ISRT
Model: claude-4-sonnet
Status: SUCCESS
Processing Time: 64149ms
Response Length: 14329 characters
Quality Score: 0.8
Timestamp: 2025-08-22T14:20:31.398414

================================================================================
RAW RESPONSE:
================================================================================
```sql
CREATE OR REPLACE PROCEDURE ACCT_BALN_BKDT_ADJ_RULE_ISRT(
    P_DDSTG_SCHEMA STRING DEFAULT 'DDSTG',
    P_VTECH_SCHEMA STRING DEFAULT 'VTECH',
    P_DEBUG_MODE BOOLEAN DEFAULT FALSE,
    P_DRY_RUN BOOLEAN DEFAULT FALSE,
    ERROR_TABLE STRING DEFAULT 'PROCESS_ERROR_LOG',
    PROCESS_KEY STRING DEFAULT 'ACCT_BALN_BKDT_ADJ_RULE_ISRT'
)
RETURNS STRING
LANGUAGE SQL
EXECUTE AS CALLER
AS
$$
DECLARE
-- =============================================================================
-- Procedure: ACCT_BALN_BKDT_ADJ_RULE_ISRT
-- Purpose: Calculate backdated adjustments from ACCT_BALN_ADJ and apply to ACCT_BALN
-- 
-- Description: This procedure processes account balance adjustments by calculating
--              backdated adjustment periods based on business day rules and applies
--              complex date logic to determine the appropriate adjustment periods.
--
-- Parameters:
--   P_DDSTG_SCHEMA  - Target schema for staging tables (default: 'DDSTG')
--   P_VTECH_SCHEMA  - Source schema for base tables (default: 'VTECH')
--   P_DEBUG_MODE    - Enable debug logging (default: FALSE)
--   P_DRY_RUN       - Execute in dry-run mode without commits (default: FALSE)
--   ERROR_TABLE     - Error logging table (default: 'PROCESS_ERROR_LOG')
--   PROCESS_KEY     - Process identifier for logging (default: procedure name)
--
-- Returns: SUCCESS/ERROR message with processing details
--
-- Migration Notes:
--   - Converted from Teradata BTEQ script 90_ISRT_ACCT_BALN_BKDT_ADJ_RULE
--   - QUALIFY clause preserved (supported in Snowflake)
--   - Teradata interval arithmetic converted to Snowflake DATEADD/DATEDIFF
--   - ADD_MONTHS function replaced with DATEADD
--   - Complex CASE logic for backdated calculations preserved
--
-- Version History:
--   1.0  2011-07-22  Suresh Vajapeyajula  Initial Teradata version
--   2.0  2025-01-XX  Migration Team       Snowflake conversion
-- =============================================================================

    -- Control variables
    v_error_code INTEGER DEFAULT 0;
    v_error_message STRING DEFAULT '';
    v_rows_deleted INTEGER DEFAULT 0;
    v_rows_inserted INTEGER DEFAULT 0;
    v_current_step STRING DEFAULT 'INITIALIZATION';
    v_start_time TIMESTAMP_NTZ DEFAULT CURRENT_TIMESTAMP();
    v_execution_id STRING DEFAULT PROCESS_KEY || '_' || TO_CHAR(v_start_time, 'YYYYMMDDHH24MISS');
    
    -- Business logic variables
    v_last_batch_run_date DATE;
    v_adj_batch_run_date DATE;
    
    -- Dynamic SQL variables
    v_delete_sql STRING;
    v_insert_sql STRING;
    v_target_table STRING;
    
    -- Cursor for validation
    v_validation_count INTEGER DEFAULT 0;

BEGIN
    -- Initialize execution
    v_current_step := 'PARAMETER_VALIDATION';
    
    -- Validate input parameters
    IF (P_DDSTG_SCHEMA IS NULL OR TRIM(P_DDSTG_SCHEMA) = '') THEN
        RAISE EXCEPTION 'P_DDSTG_SCHEMA cannot be null or empty';
    END IF;
    
    IF (P_VTECH_SCHEMA IS NULL OR TRIM(P_VTECH_SCHEMA) = '') THEN
        RAISE EXCEPTION 'P_VTECH_SCHEMA cannot be null or empty';
    END IF;
    
    -- Construct target table reference
    v_target_table := P_DDSTG_SCHEMA || '.ACCT_BALN_BKDT_ADJ_RULE';
    
    -- Debug logging
    IF (P_DEBUG_MODE) THEN
        CALL SYSTEM$LOG('INFO', 'Starting ' || PROCESS_KEY || ' - Execution ID: ' || v_execution_id);
        CALL SYSTEM$LOG('INFO', 'Parameters - DDSTG: ' || P_DDSTG_SCHEMA || ', VTECH: ' || P_VTECH_SCHEMA);
    END IF;
    
    -- Step 1: Validate source data availability
    v_current_step := 'SOURCE_VALIDATION';
    
    -- Check if required source tables exist and have data
    SELECT COUNT(*)
    INTO v_validation_count
    FROM INFORMATION_SCHEMA.TABLES
    WHERE TABLE_SCHEMA = UPPER(P_VTECH_SCHEMA)
      AND TABLE_NAME IN ('ACCT_BALN_ADJ', 'UTIL_PROS_ISAC', 'GRD_RPRT_CALR_CLYR');
    
    IF (v_validation_count < 3) THEN
        RAISE EXCEPTION 'Required source tables not found in schema: ' || P_VTECH_SCHEMA;
    END IF;
    
    -- Get the last successful batch run dates for delta processing
    v_current_step := 'BATCH_DATE_RETRIEVAL';
    
    BEGIN
        SELECT MAX(BTCH_RUN_D)
        INTO v_last_batch_run_date
        FROM IDENTIFIER(P_VTECH_SCHEMA || '.UTIL_PROS_ISAC')
        WHERE TRGT_M = 'ACCT_BALN_BKDT' 
          AND SRCE_SYST_M = 'GDW'
          AND COMT_F = 'Y' 
          AND SUCC_F = 'Y';
          
        SELECT MAX(BTCH_RUN_D)
        INTO v_adj_batch_run_date
        FROM IDENTIFIER(P_VTECH_SCHEMA || '.UTIL_PROS_ISAC')
        WHERE TRGT_M = 'ACCT_BALN_ADJ' 
          AND SRCE_SYST_M = 'SAP'
          AND COMT_F = 'Y' 
          AND SUCC_F = 'Y';
          
    EXCEPTION
        WHEN OTHER THEN
            v_error_code := SQLCODE;
            v_error_message := 'Failed to retrieve batch run dates: ' || SQLERRM;
            GOTO error_handler;
    END;
    
    IF (P_DEBUG_MODE) THEN
        CALL SYSTEM$LOG('INFO', 'Last BKDT batch date: ' || COALESCE(TO_CHAR(v_last_batch_run_date), 'NULL'));
        CALL SYSTEM$LOG('INFO', 'Last ADJ batch date: ' || COALESCE(TO_CHAR(v_adj_batch_run_date), 'NULL'));
    END IF;
    
    -- Step 2: Clear target table (equivalent to DELETE statement)
    v_current_step := 'TARGET_TABLE_CLEANUP';
    
    IF (NOT P_DRY_RUN) THEN
        v_delete_sql := 'DELETE FROM ' || v_target_table;
        
        BEGIN
            EXECUTE IMMEDIATE v_delete_sql;
            v_rows_deleted := SQLROWCOUNT;
            
            IF (P_DEBUG_MODE) THEN
                CALL SYSTEM$LOG('INFO', 'Deleted ' || v_rows_deleted || ' rows from target table');
            END IF;
            
        EXCEPTION
            WHEN OTHER THEN
                v_error_code := SQLCODE;
                v_error_message := 'Failed to delete from target table: ' || SQLERRM;
                GOTO error_handler;
        END;
    ELSE
        CALL SYSTEM$LOG('INFO', 'DRY RUN: Would delete all rows from ' || v_target_table);
    END IF;
    
    -- Step 3: Insert backdated adjustment rules with complex business logic
    v_current_step := 'BACKDATED_ADJUSTMENT_CALCULATION';
    
    v_insert_sql := '
    INSERT INTO ' || v_target_table || '
    (
        ACCT_I, 
        SRCE_SYST_C,
        BALN_TYPE_C,
        CALC_FUNC_C,
        TIME_PERD_C,
        ADJ_FROM_D,
        BKDT_ADJ_FROM_D,
        ADJ_TO_D,
        ADJ_A,
        EFFT_D,
        GL_RECN_F,
        PROS_KEY_EFFT_I               
    )
    SELECT 
        DT1.ACCT_I,
        DT1.SRCE_SYST_C, 
        DT1.BALN_TYPE_C,
        DT1.CALC_FUNC_C,
        DT1.TIME_PERD_C,
        DT1.ADJ_FROM_D,
        -- Complex backdated adjustment logic based on business day rules
        CASE 
            -- Same month: no backdating needed
            WHEN DATEDIFF(MONTH, DT1.ADJ_FROM_D, DT1.EFFT_D) = 0 
            THEN DT1.ADJ_FROM_D 
            
            -- One month difference with early business day processing
            WHEN DATEDIFF(MONTH, DT1.ADJ_FROM_D, DT1.EFFT_D) = 1 
                 AND DT1.EFFT_D <= BSDY_4.CALR_CALR_D 
            THEN DT1.ADJ_FROM_D
            
            -- One month difference with late business day processing
            WHEN DATEDIFF(MONTH, DT1.ADJ_FROM_D, DT1.EFFT_D) = 1 
                 AND DT1.EFFT_D > BSDY_4.CALR_CALR_D  
            THEN DATE_TRUNC(''MONTH'', DT1.EFFT_D)
            
            -- Multiple months with early business day processing
            WHEN DATEDIFF(MONTH, DT1.ADJ_FROM_D, DT1.EFFT_D) > 1 
                 AND DT1.EFFT_D <= BSDY_4.CALR_CALR_D 
            THEN DATEADD(MONTH, -1, DATE_TRUNC(''MONTH'', DT1.EFFT_D))
            
            -- Multiple months with late business day processing
            WHEN DATEDIFF(MONTH, DT1.ADJ_FROM_D, DT1.EFFT_D) > 1 
                 AND DT1.EFFT_D > BSDY_4.CALR_CALR_D  
            THEN DATE_TRUNC(''MONTH'', DT1.EFFT_D)
            
            ELSE DT1.ADJ_FROM_D
        END AS BKDT_ADJ_FROM_D,
        DT1.ADJ_TO_D,
        -- Aggregate similar adjustments for the same period
        SUM(DT1.ADJ_A) AS ADJ_A,
        DT1.EFFT_D,
        DT1.GL_RECN_F,
        DT1.PROS_KEY_EFFT_I
    FROM
    (
        -- Source adjustment data with effective date logic
        SELECT	
            ADJ.ACCT_I,
            ADJ.SRCE_SYST_C, 
            ADJ.BALN_TYPE_C,
            ADJ.CALC_FUNC_C,
            ADJ.TIME_PERD_C,
            ADJ.ADJ_FROM_D,
            ADJ.ADJ_TO_D,
            -- Adjust effective date to avoid impacting open balances
            CASE 
                WHEN ADJ.EFFT_D = ADJ.ADJ_TO_D 
                THEN DATEADD(DAY, 1, ADJ.EFFT_D)
                ELSE ADJ.EFFT_D 
            END AS EFFT_D,
            ADJ.GL_RECN_F,
            ADJ.ADJ_A,
            ADJ.PROS_KEY_EFFT_I
        FROM ' || P_VTECH_SCHEMA || '.ACCT_BALN_ADJ ADJ
        WHERE	
            ADJ.SRCE_SYST_C = ''SAP''
            AND ADJ.BALN_TYPE_C = ''BALN''
            AND ADJ.CALC_FUNC_C = ''SPOT'' 
            AND ADJ.TIME_PERD_C = ''E'' 
            -- Exclude zero-value adjustments to avoid negative impact
            AND ADJ.ADJ_A <> 0 
            -- Delta processing: only new adjustments since last run
            AND ADJ.EFFT_D >= COALESCE(' || COALESCE('''' || v_last_batch_run_date || '''', 'NULL') || ', ''1900-01-01'')
    ) DT1
    INNER JOIN
    (
        -- Business day 4 calculation for each month
        SELECT	
            YEAR(CALR_CALR_D) AS CALR_YEAR_N,
            MONTH(CALR_CALR_D) AS CALR_MNTH_N,
            CALR_CALR_D
        FROM ' || P_VTECH_SCHEMA || '.GRD_RPRT_CALR_CLYR
        WHERE	
            DAYOFWEEK(CALR_CALR_D) NOT IN (1, 7)  -- Exclude weekends
            AND CALR_NON_WORK_DAY_F = ''N''
            AND CALR_CALR_D BETWEEN DATEADD(MONTH, -13, CURRENT_DATE()) 
                                AND DATEADD(MONTH, 1, CURRENT_DATE())
        QUALIFY ROW_NUMBER() OVER (
            PARTITION BY YEAR(CALR_CALR_D), MONTH(CALR_CALR_D) 
            ORDER BY CALR_CALR_D
        ) = 4
    ) BSDY_4
    ON YEAR(DT1.EFFT_D) = BSDY_4.CALR_YEAR_N
       AND MONTH(DT1.EFFT_D) = BSDY_4.CALR_MNTH_N
    WHERE
        -- Include adjustments from previous runs for open records
        DT1.EFFT_D <= COALESCE(' || COALESCE('''' || v_adj_batch_run_date || '''', 'NULL') || ', CURRENT_DATE())
        -- Exclude already processed records
        AND DT1.EFFT_D > COALESCE(' || COALESCE('''' || v_last_batch_run_date || '''', 'NULL') || ', ''1900-01-01'')
    GROUP BY 
        DT1.ACCT_I, DT1.SRCE_SYST_C, DT1.BALN_TYPE_C, DT1.CALC_FUNC_C, 
        DT1.TIME_PERD_C, DT1.ADJ_FROM_D, 7, DT1.ADJ_TO_D, DT1.EFFT_D, 
        DT1.GL_RECN_F, DT1.PROS_KEY_EFFT_I
    HAVING 
        -- Final validation: ensure backdated period is valid
        MAX(CASE 
            WHEN DATEDIFF(MONTH, DT1.ADJ_FROM_D, DT1.EFFT_D) = 0 
            THEN DT1.ADJ_FROM_D 
            WHEN DATEDIFF(MONTH, DT1.ADJ_FROM_D, DT1.EFFT_D) = 1 
                 AND DT1.EFFT_D <= BSDY_4.CALR_CALR_D 
            THEN DT1.ADJ_FROM_D
            WHEN DATEDIFF(MONTH, DT1.ADJ_FROM_D, DT1.EFFT_D) = 1 
                 AND DT1.EFFT_D > BSDY_4.CALR_CALR_D  
            THEN DATE_TRUNC(''MONTH'', DT1.EFFT_D)
            WHEN DATEDIFF(MONTH, DT1.ADJ_FROM_D, DT1.EFFT_D) > 1 
                 AND DT1.EFFT_D <= BSDY_4.CALR_CALR_D 
            THEN DATEADD(MONTH, -1, DATE_TRUNC(''MONTH'', DT1.EFFT_D))
            WHEN DATEDIFF(MONTH, DT1.ADJ_FROM_D, DT1.EFFT_D) > 1 
                 AND DT1.EFFT_D > BSDY_4.CALR_CALR_D  
            THEN DATE_TRUNC(''MONTH'', DT1.EFFT_D)
            ELSE DT1.ADJ_FROM_D
        END) <= MAX(DT1.ADJ_TO_D)';
    
    IF (NOT P_DRY_RUN) THEN
        BEGIN
            EXECUTE IMMEDIATE v_insert_sql;
            v_rows_inserted := SQLROWCOUNT;
            
            IF (P_DEBUG_MODE) THEN
                CALL SYSTEM$LOG('INFO', 'Inserted ' || v_rows_inserted || ' rows into target table');
            END IF;
            
        EXCEPTION
            WHEN OTHER THEN
                v_error_code := SQLCODE;
                v_error_message := 'Failed to insert backdated adjustment rules: ' || SQLERRM;
                GOTO error_handler;
        END;
    ELSE
        CALL SYSTEM$LOG('INFO', 'DRY RUN: Would execute insert statement');
        v_rows_inserted := 0;
    END IF;
    
    -- Step 4: Final validation and statistics
    v_current_step := 'FINAL_VALIDATION';
    
    IF (NOT P_DRY_RUN) THEN
        SELECT COUNT(*)
        INTO v_validation_count
        FROM IDENTIFIER(v_target_table);
        
        IF (v_validation_count != v_rows_inserted) THEN
            RAISE EXCEPTION 'Data validation failed: Expected ' || v_rows_inserted || ' rows, found ' || v_validation_count;
        END IF;
    END IF;
    
    -- Success completion
    v_current_step := 'COMPLETED_SUCCESSFULLY';
    
    RETURN 'SUCCESS: ' || PROCESS_KEY || ' completed successfully. ' ||
           'Execution ID: ' || v_execution_id || ', ' ||
           'Rows deleted: ' || v_rows_deleted || ', ' ||
           'Rows inserted: ' || v_rows_inserted || ', ' ||
           'Duration: ' || DATEDIFF(SECOND, v_start_time, CURRENT_TIMESTAMP()) || ' seconds' ||
           CASE WHEN P_DRY_RUN THEN ' (DRY RUN MODE)' ELSE '' END;

error_handler:
    -- Comprehensive error logging and cleanup
    BEGIN
        -- Log to error table if available
        EXECUTE IMMEDIATE 
            'INSERT INTO ' || ERROR_TABLE || ' 
             (PROCESS_KEY, EXECUTION_ID, ERROR_CODE, ERROR_MESSAGE, ERROR_STEP, ERROR_TIMESTAMP) 
             VALUES (?, ?, ?, ?, ?, ?)' 
        USING (PROCESS_KEY, v_execution_id, v_error_code, v_error_message, v_current_step, CURRENT_TIMESTAMP());
    EXCEPTION
        WHEN OTHER THEN
            -- If error table insert fails, continue with return
            NULL;
    END;
    
    -- Rollback any partial changes
    IF (NOT P_DRY_RUN) THEN
        ROLLBACK;
    END IF;
    
    RETURN 'ERROR: ' || PROCESS_KEY || ' failed at step ' || v_current_step || '. ' ||
           'Execution ID: ' || v_execution_id || ', ' ||
           'Error: ' || v_error_message || ' (Code: ' || v_error_code || ')';

EXCEPTION
    WHEN OTHER THEN
        -- Handle any unhandled exceptions
        RETURN 'FATAL ERROR: ' || PROCESS_KEY || ' encountered unexpected error. ' ||
               'Execution ID: ' || v_execution_id || ', ' ||
               'Error: ' || SQLERRM || ' (Code: ' || SQLCODE || ')';
END;
$$;
```