{
  "interaction_id": "20250821_171122_467317a1",
  "timestamp": "2025-08-21T17:11:22.347553",
  "provider": "snowflake_cortex",
  "model": "snowflake-llama-3.3-70b",
  "request_type": "dbt_conversion",
  "prompt": "# BTEQ SQL to DBT Model Conversion\n\nYou are a senior data engineer expert in converting legacy BTEQ SQL scripts to modern DBT models with Jinja templating.\n\n## CRITICAL INSTRUCTIONS - NO HALLUCINATION POLICY\n- ONLY transform the logic provided in the source BTEQ SQL\n- DO NOT add new business logic, columns, or transformations\n- DO NOT create new table references not in the original\n- PRESERVE all existing business logic exactly\n- If unclear about any logic, maintain the original approach\n\n## Source Context\n\n### 1. Original BTEQ SQL Script\n```sql\n.RUN FILE=%%BTEQ_LOGON_SCRIPT%%\n.IF ERRORCODE <> 0 THEN .GOTO EXITERR\n\n.SET QUIET OFF\n.SET ECHOREQ ON\n.SET FORMAT OFF\n.SET WIDTH 120\n\n------------------------------------------------------------------------------\n--  SCRIPT NAME: 90_ISRT_ACCT_BALN_BKDT_ADJ_RULE\n--Description: Calculate the Backdated adjustment from ACCT BALN ADJ and apply \n--it on ACCT BALN\n--\n--  Ver  Date       Modified By        \t\t    Description\n--  ---- ---------- ---------------------------------------------------------\n--  1.0  22/07/2011 Suresh Vajapeyajula        \tInitial Version\n\n-- $LastChangedBy: vajapes $\n-- $LastChangedDate: 2012-02-28 09:08:17 +1100 (Tue, 28 Feb 2012) $\n-- $LastChangedRevision: 9216 $\n\n------------------------------------------------------------------------------\n\n\nDELETE %%DDSTG%%.ACCT_BALN_BKDT_ADJ_RULE;\n\n.IF ERRORCODE <> 0 THEN .GOTO EXITERR\n\nINSERT INTO %%DDSTG%%.ACCT_BALN_BKDT_ADJ_RULE\n(\nACCT_I, \nSRCE_SYST_C,\nBALN_TYPE_C,\nCALC_FUNC_C,\nTIME_PERD_C,\nADJ_FROM_D,\nBKDT_ADJ_FROM_D,\nADJ_TO_D,\nADJ_A,\nEFFT_D,\nGl_RECN_F,\nPROS_KEY_EFFT_I               \n)\nSELECT \nDT1.ACCT_I,\nDT1.SRCE_SYST_C, \nDT1.BALN_TYPE_C,\nDT1.CALC_FUNC_C,\nDT1.TIME_PERD_C,\nDT1.ADJ_FROM_D,\nCASE WHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4))  = 0 \nTHEN DT1.ADJ_FROM_D \n/*Backdated logic calculation when diffrence of months is 1 \nand DT1.EFFT_D is between Business day 1 and Biz day 4*/\nWHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4))  = 1 \nAND DT1.EFFT_D <= BSDY_4.CALR_CALR_D THEN DT1.ADJ_FROM_D\n\n/*Backdated logic calculation when diffrence of months is 1 \nand DT1.EFFT_D is NOT between Business day 1 and Biz day 4*/\nWHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4)) = 1 \nAND DT1.EFFT_D > BSDY_4.CALR_CALR_D  THEN  DT1.EFFT_D - (EXTRACT (DAY FROM DT1.EFFT_D) - 1)  \n\n/*Backdated logic calculation when diffrence of months is greater than 1 \nand DT1.EFFT_D is between Business day 1 and Biz day 4*/\nWHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4))> 1 \nAND DT1.EFFT_D <= BSDY_4.CALR_CALR_D \nTHEN DT1.EFFT_D - (EXTRACT (DAY FROM DT1.EFFT_D) - 1)-INTERVAL '1' MONTH\n\n/*Backdated logic calculation when diffrence of months is greater than 1 \nand DT1.EFFT_D is  NOT between Business day 1 and Biz day 4*/\nWHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4))  > 1 \nAND DT1.EFFT_D > BSDY_4.CALR_CALR_D  THEN DT1.EFFT_D - (EXTRACT (DAY FROM DT1.EFFT_D) - 1) \nEND AS BKDT_ADJ_FROM_D,\nDT1.ADJ_TO_D,\n/*Similar adjustments for the same period are added */\nSUM(DT1.ADJ_A) AS ADJ_A,\nDT1.EFFT_D,\nDT1.Gl_RECN_F,\nDT1.PROS_KEY_EFFT_I\nFROM\n(\nSELECT\t\nADJ.ACCT_I AS ACCT_I,\nADJ.SRCE_SYST_C AS SRCE_SYST_C, \nADJ.BALN_TYPE_C AS BALN_TYPE_C,\nADJ.CALC_FUNC_C AS CALC_FUNC_C,\nADJ.TIME_PERD_C AS TIME_PERD_C,\nADJ.ADJ_FROM_D AS ADJ_FROM_D,\nADJ.ADJ_TO_D,\n/*Adjustments impacting the current record need to be loaded on the next day to avoid changing the open balances\n*/\n(CASE WHEN ADJ.EFFT_D = ADJ.ADJ_TO_D THEN EFFT_D+1\nELSE EFFT_D END) AS EFFT_D,\nADJ.Gl_RECN_F,\nADJ_A,\nPROS_KEY_EFFT_I\nFROM\n%%VTECH%%.ACCT_BALN_ADJ  ADJ\nWHERE\t\nSRCE_SYST_C = 'SAP'\nAND BALN_TYPE_C='BALN'\nAND CALC_FUNC_C='SPOT' \nAND TIME_PERD_C = 'E' \n/*Excluding the adjustments  with $0 in value as this brings no change to the \n$value in tha ACCT BALN and had a negative impact on the last records in \nACCT BALN, so considerably important to eliminate*/\nAND ADJ.ADJ_A <> 0 \n/* Capturing delta adjustments*/\nAND ADJ.EFFT_D >= \n\t(SELECT MAX(BTCH_RUN_D) \n\tFROM %%VTECH%%.UTIL_PROS_ISAC \n\tWHERE    TRGT_M='ACCT_BALN_BKDT' AND SRCE_SYST_M='GDW'\n\tAND COMT_F = 'Y'  \tAND SUCC_F='Y')\n)DT1\nINNER JOIN\n(\n/*Calulation of Business day 4 Logic*/\nSELECT\t\nCALR_YEAR_N,\nCALR_MNTH_N,\nCALR_CALR_D\nFROM\t\n%%VTECH%%.GRD_RPRT_CALR_CLYR\nWHERE\t\nCALR_WEEK_DAY_N NOT IN (1,7) \nAND CALR_NON_WORK_DAY_F = 'N'\nAND CALR_CALR_D BETWEEN  ADD_MONTHS(CURRENT_DATE,-13) AND ADD_MONTHS(CURRENT_DATE,+1)\nQUALIFY\tROW_NUMBER() OVER (PARTITION BY CALR_YEAR_N, CALR_MNTH_N \nORDER\tBY CALR_CALR_D) = 4\n)BSDY_4\nON EXTRACT (YEAR \nFROM DT1.EFFT_D)=EXTRACT (YEAR FROM BSDY_4.CALR_CALR_D)\nAND EXTRACT (MONTH FROM DT1.EFFT_D)=EXTRACT (MONTH FROM BSDY_4.CALR_CALR_D)\n\nWHERE\n/*Including the adjustments that are excluded  in the previous run  for open record*/\nDT1.EFFT_D <= (SELECT MAX(BTCH_RUN_D) AS BTCH_RUN_D\nFROM %%VTECH%%.UTIL_PROS_ISAC\nWHERE    TRGT_M='ACCT_BALN_ADJ' AND SRCE_SYST_M='SAP'\nAND COMT_F = 'Y'  AND SUCC_F='Y')\n\n/*To avoid any records that are processed in the previous runs */\nAND  DT1.EFFT_D > (SELECT MAX(BTCH_RUN_D) AS BTCH_RUN_D\nFROM %%VTECH%%.UTIL_PROS_ISAC\nWHERE    \nTRGT_M='ACCT_BALN_BKDT' AND SRCE_SYST_M='GDW'\nAND COMT_F = 'Y'  AND SUCC_F='Y')\n\n/*To exclude any adjustments that fall in the period where the GL is closed*/\nAND BKDT_ADJ_FROM_D <= ADJ_TO_D\n\nGROUP BY ACCT_I,SRCE_SYST_C, BALN_TYPE_C ,CALC_FUNC_C,TIME_PERD_C,ADJ_FROM_D,\nBKDT_ADJ_FROM_D,ADJ_TO_D,EFFT_D,Gl_RECN_F, PROS_KEY_EFFT_I;\n\n\n.IF ERRORCODE <> 0 THEN .GOTO EXITERR\n\n.QUIT 0\n.LOGOFF\n\n.LABEL EXITERR\n.QUIT 1\n.LOGOFF\n.EXIT\n```\n\n### 2. Reference Stored Procedure Translation (for context)\n```sql\nCREATE OR REPLACE PROCEDURE ACCT_BALN_BKDT_ADJ_RULE_ISRT\n(\n    ERROR_TABLE STRING DEFAULT 'PROCESS_ERROR_LOG',\n    PROCESS_KEY STRING DEFAULT 'UNKNOWN_PROCESS'\n  )\n  RETURNS STRING\n  LANGUAGE SQL\n  EXECUTE AS CALLER\nAS\n$$\nDECLARE\n  -- Variable declarations\n  LET error_code INTEGER DEFAULT 0;\n  LET sql_state STRING DEFAULT '00000';\n  LET error_message STRING DEFAULT '';\n  LET row_count INTEGER DEFAULT 0;\n  LET current_step STRING DEFAULT 'INIT';\n\n  -- Exception handling setup\n  DECLARE\n    general_exception EXCEPTION (-20001, 'General procedure error');\n  BEGIN\n    -- Main procedure logic starts here\n\n    -- Success path\n    RETURN 'SUCCESS: ' || current_step || ' completed. Rows processed: ' || row_count;\n\n    -- Error handling\n    error_exit:\n      -- Log error to error table if available\n      INSERT INTO IDENTIFIER(:ERROR_TABLE) (PROCESS_KEY, ERROR_CODE, ERROR_MESSAGE, ERROR_TIMESTAMP)\n      VALUES (:PROCESS_KEY, error_code, error_message, CURRENT_TIMESTAMP());\n      \n      RETURN 'ERROR: ' || error_message || ' (Code: ' || error_code || ')';\n\n  EXCEPTION\n    WHEN OTHER THEN\n      RETURN 'FATAL ERROR: ' || SQLERRM || ' (Code: ' || SQLCODE || ')';\nEND;\n$$;\n```\n\n### 3. Additional Analysis\nStreamlined BTEQ to DBT conversion for ACCT_BALN_BKDT_ADJ_RULE_ISRT\n\n\n## DBT Conversion Requirements\n\n### 1. DBT Model Structure\n- Start with proper Jinja config block using config() macro\n- Use appropriate materialization strategy (table, view, incremental)\n- Add meaningful tags for categorization\n- Include pre_hook and post_hook for logging if needed\n- Set proper database/schema references using vars\n\n### 2. SQL Best Practices\n- Use modern SQL patterns (CTEs over subqueries where beneficial)\n- Implement proper column naming and aliasing\n- Add clear comments explaining business logic\n- Use explicit column lists (avoid SELECT *)\n- Optimize JOIN patterns and WHERE clause ordering\n\n### 3. DCF Table Reference Standards\n- DO NOT use ref() macro for source tables - use proper database.schema variable constructs\n- Transform table references like: `%%VTECH%%.ACCT_BALN_ADJ` → `{ var('vtech_db') }.{ var('vtech_sch') }.ACCT_BALN_ADJ`\n- Transform table references like: `%%GDWREF%%.GRD_RPRT_CALR_CLYR` → `{ var('gdwref_db') }.{ var('gdwref_sch') }.GRD_RPRT_CALR_CLYR`\n- Use var() macro for configuration values and database/schema references\n- Use proper table aliases (lowercase) after table references\n- Add data quality tests where appropriate\n- Use DBT's built-in functions for date/time operations\n\n### 4. DCF Materialization Strategy (REQUIRED)\n- ALWAYS use materialized='ibrg_cld_table' (never use table, view, or incremental)\n- ALWAYS include incremental_strategy='truncate-load' when DELETE+INSERT pattern exists\n- ALWAYS include tmp_database=var('dcf_database')\n- ALWAYS include tmp_schema=var('dcf_schema')\n- ALWAYS include tmp_relation_type='view'\n\n### 5. DCF Configuration Standards (REQUIRED)\n- ALWAYS use database=var('target_database')\n- ALWAYS use schema='DDSTG' (not dynamic schema variables)\n- Add meaningful tags for data lineage and process categorization\n- Include pre/post hooks for DCF process logging with specific process names\n- Use DCF-compliant log_dcf_exec_msg macro calls\n\n### 6. Code Organization\n- Use clear CTE naming that describes the transformation\n- Group related logic into logical CTEs\n- Add section comments for major transformations\n- Maintain proper indentation and formatting\n\n## Expected DBT Model Output Format\n\nThe output should be a complete DBT model file with:\n\n```sql\n{%- set process_name = 'YOUR_PROCESS_NAME' -%}\n{%- set stream_name = 'YOUR_STREAM_NAME' -%}\n\n{{\n  config(\n    materialized='ibrg_cld_table',\n    incremental_strategy='truncate-load',\n    database=var('target_database'),\n    schema='DDSTG',\n    tmp_database=var('dcf_database'),\n    tmp_schema=var('dcf_schema'),\n    tmp_relation_type='view',\n    tags=['stream_name', 'process_category', 'core_transform', 'specific_tags'],\n    pre_hook=[\n        \"{{ log_dcf_exec_msg('Process your_process_name started') }}\"\n    ],\n    post_hook=[\n        \"{{ log_dcf_exec_msg('Process your_process_name ended') }}\"\n    ]\n  )\n}}\n\n/*\n    Model Documentation\n    Purpose: Brief description\n    Business Logic: Key transformations\n    Dependencies: Source database.schema.tables (use var() constructs, not ref() calls)\n*/\n\nWITH cte_name AS (\n    SELECT\n        col1,\n        col2\n    FROM {{ var('source_db') }}.{{ var('source_sch') }}.SOURCE_TABLE alias\n    WHERE condition\n),\n\nfinal AS (\n    SELECT ...\n)\n\nSELECT * FROM final\n```\n\n## Specific Transformation Guidance\n\n### BTEQ Control Flow → DBT Patterns\n- Convert DELETE + INSERT patterns to proper materialization\n- Replace BTEQ variables with DBT vars and Jinja variables\n- Transform error handling to DBT test patterns where possible\n- Convert procedural logic to declarative SQL transformations\n\n### Date/Time Functions\n- Use DBT date functions or modern SQL equivalents\n- Replace Teradata date arithmetic with standard functions\n- Maintain timezone handling if present\n\n### Process Control Tables\n- Reference process control tables using database.schema variable constructs: { var('control_db') }.{ var('control_sch') }.TABLE_NAME\n- Use var() for process configuration values and database/schema references\n- Implement delta processing via incremental materialization with 'truncate-load' strategy\n\n## Output Instructions\n\nProvide ONLY the complete DBT model SQL code. Do not include explanations, markdown formatting, or additional commentary.\n\n## DBT Model:",
  "prompt_length": 11165,
  "prompt_hash": "467317a14783f58b45714a9f9809d22b",
  "temperature": null,
  "max_tokens": null,
  "response": "```sql\n{%- set process_name = 'ACCT_BALN_BKDT_ADJ_RULE' -%}\n{%- set stream_name = 'ACCT_BALN_BKDT_ADJ_RULE_STREAM' -%}\n\n{{\n  config(\n    materialized='ibrg_cld_table',\n    incremental_strategy='truncate-load',\n    database=var('target_database'),\n    schema='DDSTG',\n    tmp_database=var('dcf_database'),\n    tmp_schema=var('dcf_schema'),\n    tmp_relation_type='view',\n    tags=['ACCT_BALN_BKDT_ADJ_RULE', 'core_transform', 'accounting'],\n    pre_hook=[\n        \"{{ log_dcf_exec_msg('Process ACCT_BALN_BKDT_ADJ_RULE started') }}\"\n    ],\n    post_hook=[\n        \"{{ log_dcf_exec_msg('Process ACCT_BALN_BKDT_ADJ_RULE ended') }}\"\n    ]\n  )\n}}\n\n/*\n    Model Documentation\n    Purpose: Calculate the Backdated adjustment from ACCT BALN ADJ and apply it on ACCT BALN\n    Business Logic: Key transformations include calculating backdated adjustments based on business day 4 logic\n    Dependencies: {{ var('vtech_db') }}.{{ var('vtech_sch') }}.ACCT_BALN_ADJ, {{ var('vtech_db') }}.{{ var('vtech_sch') }}.GRD_RPRT_CALR_CLYR, {{ var('gdwref_db') }}.{{ var('gdwref_sch') }}.UTIL_PROS_ISAC\n*/\n\nWITH \n-- Calculate adjustments for the current record\nADJ AS (\n    SELECT\n        ACCT_I,\n        SRCE_SYST_C,\n        BALN_TYPE_C,\n        CALC_FUNC_C,\n        TIME_PERD_C,\n        ADJ_FROM_D,\n        -- Adjustments impacting the current record need to be loaded on the next day to avoid changing the open balances\n        CASE \n            WHEN EFFT_D = ADJ_TO_D THEN EFFT_D + INTERVAL '1 day'\n            ELSE EFFT_D\n        END AS EFFT_D,\n        ADJ_TO_D,\n        ADJ_A,\n        Gl_RECN_F,\n        PROS_KEY_EFFT_I\n    FROM \n        {{ var('vtech_db') }}.{{ var('vtech_sch') }}.ACCT_BALN_ADJ\n    WHERE \n        SRCE_SYST_C = 'SAP'\n        AND BALN_TYPE_C = 'BALN'\n        AND CALC_FUNC_C = 'SPOT'\n        AND TIME_PERD_C = 'E'\n        -- Excluding the adjustments with $0 in value as this brings no change to the value in the ACCT BALN\n        AND ADJ_A <> 0\n        -- Capturing delta adjustments\n        AND EFFT_D >= (\n            SELECT \n                MAX(BTCH_RUN_D) \n            FROM \n                {{ var('gdwref_db') }}.{{ var('gdwref_sch') }}.UTIL_PROS_ISAC \n            WHERE \n                TRGT_M = 'ACCT_BALN_BKDT' \n                AND SRCE_M = 'GDW'\n                AND COMT_F = 'Y' \n                AND SUCC_F = 'Y'\n        )\n),\n\n-- Calculate business day 4 logic\nBSDY_4 AS (\n    SELECT \n        CALR_YEAR_N,\n        CALR_MNTH_N,\n        CALR_CALR_D\n    FROM \n        {{ var('vtech_db') }}.{{ var('vtech_sch') }}.GRD_RPRT_CALR_CLYR\n    WHERE \n        CALR_WEEK_DAY_N NOT IN (1, 7) \n        AND CALR_NON_WORK_DAY_F = 'N'\n        AND CALR_CALR_D BETWEEN ADD_MONTHS(CURRENT_DATE, -13) AND ADD_MONTHS(CURRENT_DATE, 1)\n    QUALIFY \n        ROW_NUMBER() OVER (PARTITION BY CALR_YEAR_N, CALR_MNTH_N ORDER BY CALR_CALR_D) = 4\n),\n\n-- Calculate backdated adjustments\nBKDT_ADJ AS (\n    SELECT \n        ADJ.ACCOUNT_I,\n        ADJ.SRCE_SYST_C,\n        ADJ.BALN_TYPE_C,\n        ADJ.CALC_FUNC_C,\n        ADJ.TIME_PERD_C,\n        ADJ.ADJ_FROM_D,\n        -- Backdated logic calculation\n        CASE \n            WHEN (ADJ.EFFT_D - ADJ.ADJ_FROM_D) / INTERVAL '1 month' = 0 \n                THEN ADJ.ADJ_FROM_D\n            WHEN (ADJ.EFFT_D - ADJ.ADJ_FROM_D) / INTERVAL '1 month' = 1 \n                AND ADJ.EFFT_D <= BSDY_4.CALR_CALR_D \n                THEN ADJ.ADJ_FROM_D\n            WHEN (ADJ.EFFT_D - ADJ.ADJ_FROM_D) / INTERVAL '1 month' = 1 \n                AND ADJ.EFFT_D > BSDY_4.CALR_CALR_D \n                THEN ADJ.EFFT_D - (EXTRACT(DAY FROM ADJ.EFFT_D) - 1)\n            WHEN (ADJ.EFFT_D - ADJ.ADJ_FROM_D) / INTERVAL '1 month' > 1 \n                AND ADJ.EFFT_D <= BSDY_4.CALR_CALR_D \n                THEN ADJ.EFFT_D - (EXTRACT(DAY FROM ADJ.EFFT_D) - 1) - INTERVAL '1 month'\n            WHEN (ADJ.EFFT_D - ADJ.ADJ_FROM_D) / INTERVAL '1 month' > 1 \n                AND ADJ.EFFT_D > BSDY_4.CALR_CALR_D \n                THEN ADJ.EFFT_D - (EXTRACT(DAY FROM ADJ.EFFT_D) - 1)\n        END AS BKDT_ADJ_FROM_D,\n        ADJ.ADJ_TO_D,\n        SUM(ADJ.ADJ_A) AS ADJ_A,\n        ADJ.EFFT_D,\n        ADJ.Gl_RECN_F,\n        ADJ.PROS_KEY_EFFT_I\n    FROM \n        ADJ\n    INNER JOIN \n        BSDY_4 \n        ON EXTRACT(YEAR FROM ADJ.EFFT_D) = EXTRACT(YEAR FROM BSDY_4.CALR_CALR_D)\n        AND EXTRACT(MONTH FROM ADJ.EFFT_D) = EXTRACT(MONTH FROM BSDY_4.CALR_CALR_D)\n    WHERE \n        -- Including the adjustments that are excluded in the previous run for open record\n        ADJ.EFFT_D <= (\n            SELECT \n                MAX(BTCH_RUN_D) \n            FROM \n                {{ var('gdwref_db') }}.{{ var('gdwref_sch') }}.UTIL_PROS_ISAC \n            WHERE \n                TRGT_M = 'ACCT_BALN_ADJ' \n                AND SRCE_M = 'SAP'\n                AND COMT_F = 'Y' \n                AND SUCC_F = 'Y'\n        )\n        -- To avoid any records that are processed in the previous runs\n        AND ADJ.EFFT_D > (\n            SELECT \n                MAX(BTCH_RUN_D) \n            FROM \n                {{ var('gdwref_db') }}.{{ var('gdwref_sch') }}.UTIL_PROS_ISAC \n            WHERE \n                TRGT_M = 'ACCT_BALN_BKDT' \n                AND SRCE_M = 'GDW'\n                AND COMT_F = 'Y' \n                AND SUCC_F = 'Y'\n        )\n        -- To exclude any adjustments that fall in the period where the GL is closed\n        AND BKDT_ADJ_FROM_D <= ADJ.ADJ_TO_D\n    GROUP BY \n        ADJ.ACCOUNT_I,\n        ADJ.SRCE_SYST_C,\n        ADJ.BALN_TYPE_C,\n        ADJ.CALC_FUNC_C,\n        ADJ.TIME_PERD_C,\n        ADJ.ADJ_FROM_D,\n        BKDT_ADJ_FROM_D,\n        ADJ.ADJ_TO_D,\n        ADJ.EFFT_D,\n        ADJ.Gl_RECN_F,\n        ADJ.PROS_KEY_EFFT_I\n)\n\nSELECT \n    ACCOUNT_I,\n    SRCE_SYST_C,\n    BALN_TYPE_C,\n    CALC_FUNC_C,\n    TIME_PERD_C,\n    ADJ_FROM_D,\n    BKDT_ADJ_FROM_D,\n    ADJ_TO_D,\n    ADJ_A,\n    EFFT_D,\n    Gl_RECN_F,\n    PROS_KEY_EFFT_I\nFROM \n    BKDT_ADJ\n```",
  "response_length": 5850,
  "response_hash": "6096c1d46285d77789419c463ed9e976",
  "context_data": {
    "procedure_name": "ACCT_BALN_BKDT_ADJ_RULE_ISRT",
    "conversion_type": "bteq_to_dbt"
  },
  "processing_time_ms": 24600,
  "success": true,
  "error_message": null,
  "quality_score": null,
  "enhancements_detected": null
}