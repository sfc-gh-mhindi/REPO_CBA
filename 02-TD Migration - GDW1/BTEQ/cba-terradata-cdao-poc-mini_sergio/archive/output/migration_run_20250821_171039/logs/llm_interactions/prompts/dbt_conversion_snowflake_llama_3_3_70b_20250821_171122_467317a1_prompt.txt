# LLM Request
Interaction ID: 20250821_171122_467317a1
Timestamp: 2025-08-21T17:11:22.347553
Provider: snowflake_cortex
Model: snowflake-llama-3.3-70b
Request Type: dbt_conversion
Temperature: None
Max Tokens: None

# Context Data
{
  "procedure_name": "ACCT_BALN_BKDT_ADJ_RULE_ISRT",
  "conversion_type": "bteq_to_dbt"
}

# Prompt
# BTEQ SQL to DBT Model Conversion

You are a senior data engineer expert in converting legacy BTEQ SQL scripts to modern DBT models with Jinja templating.

## CRITICAL INSTRUCTIONS - NO HALLUCINATION POLICY
- ONLY transform the logic provided in the source BTEQ SQL
- DO NOT add new business logic, columns, or transformations
- DO NOT create new table references not in the original
- PRESERVE all existing business logic exactly
- If unclear about any logic, maintain the original approach

## Source Context

### 1. Original BTEQ SQL Script
```sql
.RUN FILE=%%BTEQ_LOGON_SCRIPT%%
.IF ERRORCODE <> 0 THEN .GOTO EXITERR

.SET QUIET OFF
.SET ECHOREQ ON
.SET FORMAT OFF
.SET WIDTH 120

------------------------------------------------------------------------------
--  SCRIPT NAME: 90_ISRT_ACCT_BALN_BKDT_ADJ_RULE
--Description: Calculate the Backdated adjustment from ACCT BALN ADJ and apply 
--it on ACCT BALN
--
--  Ver  Date       Modified By        		    Description
--  ---- ---------- ---------------------------------------------------------
--  1.0  22/07/2011 Suresh Vajapeyajula        	Initial Version

-- $LastChangedBy: vajapes $
-- $LastChangedDate: 2012-02-28 09:08:17 +1100 (Tue, 28 Feb 2012) $
-- $LastChangedRevision: 9216 $

------------------------------------------------------------------------------


DELETE %%DDSTG%%.ACCT_BALN_BKDT_ADJ_RULE;

.IF ERRORCODE <> 0 THEN .GOTO EXITERR

INSERT INTO %%DDSTG%%.ACCT_BALN_BKDT_ADJ_RULE
(
ACCT_I, 
SRCE_SYST_C,
BALN_TYPE_C,
CALC_FUNC_C,
TIME_PERD_C,
ADJ_FROM_D,
BKDT_ADJ_FROM_D,
ADJ_TO_D,
ADJ_A,
EFFT_D,
Gl_RECN_F,
PROS_KEY_EFFT_I               
)
SELECT 
DT1.ACCT_I,
DT1.SRCE_SYST_C, 
DT1.BALN_TYPE_C,
DT1.CALC_FUNC_C,
DT1.TIME_PERD_C,
DT1.ADJ_FROM_D,
CASE WHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4))  = 0 
THEN DT1.ADJ_FROM_D 
/*Backdated logic calculation when diffrence of months is 1 
and DT1.EFFT_D is between Business day 1 and Biz day 4*/
WHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4))  = 1 
AND DT1.EFFT_D <= BSDY_4.CALR_CALR_D THEN DT1.ADJ_FROM_D

/*Backdated logic calculation when diffrence of months is 1 
and DT1.EFFT_D is NOT between Business day 1 and Biz day 4*/
WHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4)) = 1 
AND DT1.EFFT_D > BSDY_4.CALR_CALR_D  THEN  DT1.EFFT_D - (EXTRACT (DAY FROM DT1.EFFT_D) - 1)  

/*Backdated logic calculation when diffrence of months is greater than 1 
and DT1.EFFT_D is between Business day 1 and Biz day 4*/
WHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4))> 1 
AND DT1.EFFT_D <= BSDY_4.CALR_CALR_D 
THEN DT1.EFFT_D - (EXTRACT (DAY FROM DT1.EFFT_D) - 1)-INTERVAL '1' MONTH

/*Backdated logic calculation when diffrence of months is greater than 1 
and DT1.EFFT_D is  NOT between Business day 1 and Biz day 4*/
WHEN ((DT1.EFFT_D - DT1.ADJ_FROM_D) YEAR(4) TO MONTH) (INTERVAL MONTH(4))  > 1 
AND DT1.EFFT_D > BSDY_4.CALR_CALR_D  THEN DT1.EFFT_D - (EXTRACT (DAY FROM DT1.EFFT_D) - 1) 
END AS BKDT_ADJ_FROM_D,
DT1.ADJ_TO_D,
/*Similar adjustments for the same period are added */
SUM(DT1.ADJ_A) AS ADJ_A,
DT1.EFFT_D,
DT1.Gl_RECN_F,
DT1.PROS_KEY_EFFT_I
FROM
(
SELECT	
ADJ.ACCT_I AS ACCT_I,
ADJ.SRCE_SYST_C AS SRCE_SYST_C, 
ADJ.BALN_TYPE_C AS BALN_TYPE_C,
ADJ.CALC_FUNC_C AS CALC_FUNC_C,
ADJ.TIME_PERD_C AS TIME_PERD_C,
ADJ.ADJ_FROM_D AS ADJ_FROM_D,
ADJ.ADJ_TO_D,
/*Adjustments impacting the current record need to be loaded on the next day to avoid changing the open balances
*/
(CASE WHEN ADJ.EFFT_D = ADJ.ADJ_TO_D THEN EFFT_D+1
ELSE EFFT_D END) AS EFFT_D,
ADJ.Gl_RECN_F,
ADJ_A,
PROS_KEY_EFFT_I
FROM
%%VTECH%%.ACCT_BALN_ADJ  ADJ
WHERE	
SRCE_SYST_C = 'SAP'
AND BALN_TYPE_C='BALN'
AND CALC_FUNC_C='SPOT' 
AND TIME_PERD_C = 'E' 
/*Excluding the adjustments  with $0 in value as this brings no change to the 
$value in tha ACCT BALN and had a negative impact on the last records in 
ACCT BALN, so considerably important to eliminate*/
AND ADJ.ADJ_A <> 0 
/* Capturing delta adjustments*/
AND ADJ.EFFT_D >= 
	(SELECT MAX(BTCH_RUN_D) 
	FROM %%VTECH%%.UTIL_PROS_ISAC 
	WHERE    TRGT_M='ACCT_BALN_BKDT' AND SRCE_SYST_M='GDW'
	AND COMT_F = 'Y'  	AND SUCC_F='Y')
)DT1
INNER JOIN
(
/*Calulation of Business day 4 Logic*/
SELECT	
CALR_YEAR_N,
CALR_MNTH_N,
CALR_CALR_D
FROM	
%%VTECH%%.GRD_RPRT_CALR_CLYR
WHERE	
CALR_WEEK_DAY_N NOT IN (1,7) 
AND CALR_NON_WORK_DAY_F = 'N'
AND CALR_CALR_D BETWEEN  ADD_MONTHS(CURRENT_DATE,-13) AND ADD_MONTHS(CURRENT_DATE,+1)
QUALIFY	ROW_NUMBER() OVER (PARTITION BY CALR_YEAR_N, CALR_MNTH_N 
ORDER	BY CALR_CALR_D) = 4
)BSDY_4
ON EXTRACT (YEAR 
FROM DT1.EFFT_D)=EXTRACT (YEAR FROM BSDY_4.CALR_CALR_D)
AND EXTRACT (MONTH FROM DT1.EFFT_D)=EXTRACT (MONTH FROM BSDY_4.CALR_CALR_D)

WHERE
/*Including the adjustments that are excluded  in the previous run  for open record*/
DT1.EFFT_D <= (SELECT MAX(BTCH_RUN_D) AS BTCH_RUN_D
FROM %%VTECH%%.UTIL_PROS_ISAC
WHERE    TRGT_M='ACCT_BALN_ADJ' AND SRCE_SYST_M='SAP'
AND COMT_F = 'Y'  AND SUCC_F='Y')

/*To avoid any records that are processed in the previous runs */
AND  DT1.EFFT_D > (SELECT MAX(BTCH_RUN_D) AS BTCH_RUN_D
FROM %%VTECH%%.UTIL_PROS_ISAC
WHERE    
TRGT_M='ACCT_BALN_BKDT' AND SRCE_SYST_M='GDW'
AND COMT_F = 'Y'  AND SUCC_F='Y')

/*To exclude any adjustments that fall in the period where the GL is closed*/
AND BKDT_ADJ_FROM_D <= ADJ_TO_D

GROUP BY ACCT_I,SRCE_SYST_C, BALN_TYPE_C ,CALC_FUNC_C,TIME_PERD_C,ADJ_FROM_D,
BKDT_ADJ_FROM_D,ADJ_TO_D,EFFT_D,Gl_RECN_F, PROS_KEY_EFFT_I;


.IF ERRORCODE <> 0 THEN .GOTO EXITERR

.QUIT 0
.LOGOFF

.LABEL EXITERR
.QUIT 1
.LOGOFF
.EXIT
```

### 2. Reference Stored Procedure Translation (for context)
```sql
CREATE OR REPLACE PROCEDURE ACCT_BALN_BKDT_ADJ_RULE_ISRT
(
    ERROR_TABLE STRING DEFAULT 'PROCESS_ERROR_LOG',
    PROCESS_KEY STRING DEFAULT 'UNKNOWN_PROCESS'
  )
  RETURNS STRING
  LANGUAGE SQL
  EXECUTE AS CALLER
AS
$$
DECLARE
  -- Variable declarations
  LET error_code INTEGER DEFAULT 0;
  LET sql_state STRING DEFAULT '00000';
  LET error_message STRING DEFAULT '';
  LET row_count INTEGER DEFAULT 0;
  LET current_step STRING DEFAULT 'INIT';

  -- Exception handling setup
  DECLARE
    general_exception EXCEPTION (-20001, 'General procedure error');
  BEGIN
    -- Main procedure logic starts here

    -- Success path
    RETURN 'SUCCESS: ' || current_step || ' completed. Rows processed: ' || row_count;

    -- Error handling
    error_exit:
      -- Log error to error table if available
      INSERT INTO IDENTIFIER(:ERROR_TABLE) (PROCESS_KEY, ERROR_CODE, ERROR_MESSAGE, ERROR_TIMESTAMP)
      VALUES (:PROCESS_KEY, error_code, error_message, CURRENT_TIMESTAMP());
      
      RETURN 'ERROR: ' || error_message || ' (Code: ' || error_code || ')';

  EXCEPTION
    WHEN OTHER THEN
      RETURN 'FATAL ERROR: ' || SQLERRM || ' (Code: ' || SQLCODE || ')';
END;
$$;
```

### 3. Additional Analysis
Streamlined BTEQ to DBT conversion for ACCT_BALN_BKDT_ADJ_RULE_ISRT


## DBT Conversion Requirements

### 1. DBT Model Structure
- Start with proper Jinja config block using config() macro
- Use appropriate materialization strategy (table, view, incremental)
- Add meaningful tags for categorization
- Include pre_hook and post_hook for logging if needed
- Set proper database/schema references using vars

### 2. SQL Best Practices
- Use modern SQL patterns (CTEs over subqueries where beneficial)
- Implement proper column naming and aliasing
- Add clear comments explaining business logic
- Use explicit column lists (avoid SELECT *)
- Optimize JOIN patterns and WHERE clause ordering

### 3. DCF Table Reference Standards
- DO NOT use ref() macro for source tables - use proper database.schema variable constructs
- Transform table references like: `%%VTECH%%.ACCT_BALN_ADJ` → `{ var('vtech_db') }.{ var('vtech_sch') }.ACCT_BALN_ADJ`
- Transform table references like: `%%GDWREF%%.GRD_RPRT_CALR_CLYR` → `{ var('gdwref_db') }.{ var('gdwref_sch') }.GRD_RPRT_CALR_CLYR`
- Use var() macro for configuration values and database/schema references
- Use proper table aliases (lowercase) after table references
- Add data quality tests where appropriate
- Use DBT's built-in functions for date/time operations

### 4. DCF Materialization Strategy (REQUIRED)
- ALWAYS use materialized='ibrg_cld_table' (never use table, view, or incremental)
- ALWAYS include incremental_strategy='truncate-load' when DELETE+INSERT pattern exists
- ALWAYS include tmp_database=var('dcf_database')
- ALWAYS include tmp_schema=var('dcf_schema')
- ALWAYS include tmp_relation_type='view'

### 5. DCF Configuration Standards (REQUIRED)
- ALWAYS use database=var('target_database')
- ALWAYS use schema='DDSTG' (not dynamic schema variables)
- Add meaningful tags for data lineage and process categorization
- Include pre/post hooks for DCF process logging with specific process names
- Use DCF-compliant log_dcf_exec_msg macro calls

### 6. Code Organization
- Use clear CTE naming that describes the transformation
- Group related logic into logical CTEs
- Add section comments for major transformations
- Maintain proper indentation and formatting

## Expected DBT Model Output Format

The output should be a complete DBT model file with:

```sql
{%- set process_name = 'YOUR_PROCESS_NAME' -%}
{%- set stream_name = 'YOUR_STREAM_NAME' -%}

{{
  config(
    materialized='ibrg_cld_table',
    incremental_strategy='truncate-load',
    database=var('target_database'),
    schema='DDSTG',
    tmp_database=var('dcf_database'),
    tmp_schema=var('dcf_schema'),
    tmp_relation_type='view',
    tags=['stream_name', 'process_category', 'core_transform', 'specific_tags'],
    pre_hook=[
        "{{ log_dcf_exec_msg('Process your_process_name started') }}"
    ],
    post_hook=[
        "{{ log_dcf_exec_msg('Process your_process_name ended') }}"
    ]
  )
}}

/*
    Model Documentation
    Purpose: Brief description
    Business Logic: Key transformations
    Dependencies: Source database.schema.tables (use var() constructs, not ref() calls)
*/

WITH cte_name AS (
    SELECT
        col1,
        col2
    FROM {{ var('source_db') }}.{{ var('source_sch') }}.SOURCE_TABLE alias
    WHERE condition
),

final AS (
    SELECT ...
)

SELECT * FROM final
```

## Specific Transformation Guidance

### BTEQ Control Flow → DBT Patterns
- Convert DELETE + INSERT patterns to proper materialization
- Replace BTEQ variables with DBT vars and Jinja variables
- Transform error handling to DBT test patterns where possible
- Convert procedural logic to declarative SQL transformations

### Date/Time Functions
- Use DBT date functions or modern SQL equivalents
- Replace Teradata date arithmetic with standard functions
- Maintain timezone handling if present

### Process Control Tables
- Reference process control tables using database.schema variable constructs: { var('control_db') }.{ var('control_sch') }.TABLE_NAME
- Use var() for process configuration values and database/schema references
- Implement delta processing via incremental materialization with 'truncate-load' strategy

## Output Instructions

Provide ONLY the complete DBT model SQL code. Do not include explanations, markdown formatting, or additional commentary.

## DBT Model: