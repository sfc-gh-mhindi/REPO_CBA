# LLM Request
Interaction ID: 20250821_154536_a22080e5
Timestamp: 2025-08-21T15:45:36.234449
Provider: snowflake_cortex
Model: snowflake-llama-3.3-70b
Request Type: dbt_conversion
Temperature: None
Max Tokens: None

# Context Data
{
  "procedure_name": "ACCT_BALN_BKDT_GET_PROS_KEY",
  "conversion_type": "bteq_to_dbt"
}

# Prompt
# BTEQ SQL to DBT Model Conversion

You are a senior data engineer expert in converting legacy BTEQ SQL scripts to modern DBT models with Jinja templating.

## CRITICAL INSTRUCTIONS - NO HALLUCINATION POLICY
- ONLY transform the logic provided in the source BTEQ SQL
- DO NOT add new business logic, columns, or transformations
- DO NOT create new table references not in the original
- PRESERVE all existing business logic exactly
- If unclear about any logic, maintain the original approach

## Source Context

### 1. Original BTEQ SQL Script
```sql
.RUN FILE=%%BTEQ_LOGON_SCRIPT%%
.IF ERRORCODE <> 0 THEN .GOTO EXITERR


.SET QUIET OFF
.SET ECHOREQ ON
.SET FORMAT OFF
.SET WIDTH 120
----------------------------------------------------------------------
-- $LastChangedBy: vajapes $
-- $LastChangedDate: 2012-02-28 09:09:07 +1100 (Tue, 28 Feb 2012) $
-- $LastChangedRevision: 9221 $
----------------------------------------------------------------------
------------------------------------------------------------------------------
--
--  Description :Capture the PROS Key and update in UTIL PROS ISAC
--
--   Ver  Date       Modified By            Description
--  ---- ---------- ---------------------- -----------------------------------
--  1.0  2011-10-05 Suresh Vajapeyajula               Initial Version
------------------------------------------------------------------------------



LOCKING TABLE %%CAD_PROD_DATA%%.UTIL_PARM FOR WRITE

/*Capture the Latest Pros Key from UTIL PARM table and update UTIL PROS ISAC.
The standard stored procedure SP_GET_PROS_KEY is not used in this solution as this is not a batch load. 
And this approach was discussed and agreed with BI Services. */

INSERT INTO %%CAD_PROD_DATA%%.UTIL_PROS_ISAC
(
PROS_KEY_I                    
,CONV_M                        
,CONV_TYPE_M                   
,PROS_RQST_S                   
,PROS_LAST_RQST_S              
,PROS_RQST_Q                   
,BTCH_RUN_D                    
,BTCH_KEY_I                    
,SRCE_SYST_M                   
,SRCE_M                        
,TRGT_M                        
,SUCC_F                        
,COMT_F                        
,COMT_S                        
,MLTI_LOAD_EFFT_D              
,SYST_S                        
,MLTI_LOAD_COMT_S              
,SYST_ET_Q                     
,SYST_UV_Q                     
,SYST_INS_Q                    
,SYST_UPD_Q                    
,SYST_DEL_Q                    
,SYST_ET_TABL_M                
,SYST_UV_TABL_M                
,SYST_HEAD_ET_TABL_M           
,SYST_HEAD_UV_TABL_M           
,SYST_TRLR_ET_TABL_M           
,SYST_TRLR_UV_TABL_M           
,PREV_PROS_KEY_I               
,HEAD_RECD_TYPE_C              
,HEAD_FILE_M                   
,HEAD_BTCH_RUN_D               
,HEAD_FILE_CRAT_S              
,HEAD_GENR_PRGM_M              
,HEAD_BTCH_KEY_I               
,HEAD_PROS_KEY_I               
,HEAD_PROS_PREV_KEY_I          
,TRLR_RECD_TYPE_C              
,TRLR_RECD_Q                   
,TRLR_HASH_TOTL_A              
,TRLR_COLM_HASH_TOTL_M         
,TRLR_EROR_RECD_Q              
,TRLR_FILE_COMT_S              
,TRLR_RECD_ISRT_Q              
,TRLR_RECD_UPDT_Q              
,TRLR_RECD_DELT_Q              
)
SELECT 
PARM_LTRL_N+1	AS PROS_KEY_I, 
'CAD_X01_ACCT_BALN_BKDT'  AS  CONV_M , 
'TD' AS  CONV_TYPE_M,
CURRENT_TIMESTAMP(0) AS  PROS_RQST_S, 
CURRENT_TIMESTAMP(0) AS  PROS_LAST_RQST_S,
1 AS  PROS_RQST_Q,
/*Inserts multiple records for each batch run in the event of any delays or failures*/
DT.CALR_CALR_D AS  BTCH_RUN_D,
/*As this solution is not part of any batch [eg, SAP], the Batch Key is populated as null*/
NULL AS  BTCH_KEY_I ,
/*Sourcing from the GDW itself and so the source system name is GDW*/
'GDW' AS  SRCE_SYST_M,
/*Applying the adjustments from ACCT_BALN_ADJ on ACCT_BALN_BKDT */
'ACCT_BALN_BKDT_ADJ' AS  SRCE_M ,
'ACCT_BALN_BKDT' AS  TRGT_M ,
'N' AS  SUCC_F ,
'N' AS  COMT_F ,
NULL AS  COMT_S ,
NULL AS  MLTI_LOAD_EFFT_D,
NULL AS  SYST_S ,
NULL AS  MLTI_LOAD_COMT_S,
NULL AS  SYST_ET_Q  ,
NULL AS  SYST_UV_Q  ,
NULL AS  SYST_INS_Q ,
NULL AS  SYST_UPD_Q ,
NULL AS  SYST_DEL_Q ,
NULL AS  SYST_ET_TABL_M  ,
NULL AS  SYST_UV_TABL_M  ,
NULL AS  SYST_HEAD_ET_TABL_M ,
NULL AS  SYST_HEAD_UV_TABL_M ,
NULL AS  SYST_TRLR_ET_TABL_M ,
NULL AS  SYST_TRLR_UV_TABL_M ,
NULL AS  PREV_PROS_KEY_I ,
NULL AS  HEAD_RECD_TYPE_C,
NULL AS  HEAD_FILE_M,
NULL AS  HEAD_BTCH_RUN_D ,
NULL AS  HEAD_FILE_CRAT_S,
NULL AS  HEAD_GENR_PRGM_M,
NULL AS  HEAD_BTCH_KEY_I ,
NULL AS  HEAD_PROS_KEY_I ,
NULL AS  HEAD_PROS_PREV_KEY_I,
NULL AS  TRLR_RECD_TYPE_C,
NULL AS  TRLR_RECD_Q,
NULL AS  TRLR_HASH_TOTL_A,
NULL AS  TRLR_COLM_HASH_TOTL_M,
NULL AS  TRLR_EROR_RECD_Q,
NULL AS  TRLR_FILE_COMT_S,
NULL AS  TRLR_RECD_ISRT_Q,
NULL AS  TRLR_RECD_UPDT_Q,
NULL AS  TRLR_RECD_DELT_Q
FROM 
%%VTECH%%.UTIL_PARM PARM
CROSS JOIN 
/*Inserts multiple records for each batch run in the event of any delays or failures. 
Capture latest Batch run date relating to the Latest delta load into ACCT_BALN_BKDT*/
(SELECT  
CAL.CALR_CALR_D
FROM
/*Capture latest Batch run date relating to the Backdated adjustment solution into ACCT_BALN_ADJ*/
(SELECT  MAX(BTCH_RUN_D) AS BTCH_RUN_D FROM %%VTECH%%.UTIL_PROS_ISAC
WHERE 
TRGT_M='ACCT_BALN_ADJ' 
AND SRCE_SYST_M='SAP'
AND COMT_F = 'Y'  
AND SUCC_F='Y' ) BALN
CROSS JOIN 
/*Capture latest Batch run date relating to the Backdated adjustment solution into ACCT_BALN_BKDT*/
(SELECT  MAX(BTCH_RUN_D) AS BTCH_RUN_D 
FROM  %%VTECH%%.UTIL_PROS_ISAC
WHERE    
TRGT_M='ACCT_BALN_BKDT' 
AND SRCE_SYST_M='GDW'
AND COMT_F = 'Y'  
AND SUCC_F='Y') BKDT 

,%%VTECH%%.GRD_RPRT_CALR_CLYR CAL

WHERE CAL.CALR_CALR_D > BKDT.BTCH_RUN_D 
AND CAL.CALR_CALR_D  <= BALN.BTCH_RUN_D
)DT
WHERE 
PARM.PARM_M='PROS_KEY'

/*Increment PROS KEY by 1 and update UTIL PARM table*/
;UPDATE %%CAD_PROD_DATA%%.UTIL_PARM
SET PARM_LTRL_N = PARM_LTRL_N + 1
WHERE
PARM_M='PROS_KEY';

.IF ERRORCODE <> 0 THEN .GOTO EXITERR

.QUIT 0
.LOGOFF

.LABEL EXITERR
.QUIT 1
.LOGOFF
.EXIT
```

### 2. Reference Stored Procedure Translation (for context)
```sql

CREATE OR REPLACE PROCEDURE ACCT_BALN_BKDT_GET_PROS_KEY()
RETURNS STRING
LANGUAGE SQL
AS
$$
BEGIN
    -- Converted from BTEQ: ACCT_BALN_BKDT_GET_PROS_KEY
    RETURN 'SUCCESS';
END;
$$;

```

### 3. Additional Analysis
BTEQ to DBT conversion for ACCT_BALN_BKDT_GET_PROS_KEY


## DBT Conversion Requirements

### 1. DBT Model Structure
- Start with proper Jinja config block using config() macro
- Use appropriate materialization strategy (table, view, incremental)
- Add meaningful tags for categorization
- Include pre_hook and post_hook for logging if needed
- Set proper database/schema references using vars

### 2. SQL Best Practices
- Use modern SQL patterns (CTEs over subqueries where beneficial)
- Implement proper column naming and aliasing
- Add clear comments explaining business logic
- Use explicit column lists (avoid SELECT *)
- Optimize JOIN patterns and WHERE clause ordering

### 3. DBT-Specific Features
- Use ref() macro for model dependencies
- Use var() macro for configuration values
- Use source() macro if referencing source tables
- Add data quality tests where appropriate
- Use DBT's built-in functions for date/time operations

### 4. Materialization Strategy
- Choose appropriate materialization based on table usage:
  * `table` for frequently queried data
  * `view` for lightweight transformations
  * `incremental` for large datasets with delta processing
- Include incremental_strategy if using incremental

### 5. Configuration Best Practices
- Use meaningful database/schema configuration
- Add appropriate tags for data lineage
- Include pre/post hooks for process logging
- Set up proper error handling in hooks

### 6. Code Organization
- Use clear CTE naming that describes the transformation
- Group related logic into logical CTEs
- Add section comments for major transformations
- Maintain proper indentation and formatting

## Expected DBT Model Output Format

The output should be a complete DBT model file with:

```sql
{%- set process_name = 'YOUR_PROCESS_NAME' -%}
{%- set stream_name = 'YOUR_STREAM_NAME' -%}

{{
  config(
    materialized='your_strategy',
    database=var('target_database'),
    schema='target_schema',
    tags=['relevant', 'tags'],
    pre_hook=[
        "{{ log_dcf_exec_msg('Process started') }}"
    ],
    post_hook=[
        "{{ log_dcf_exec_msg('Process ended') }}"
    ]
  )
}}

/*
    Model Documentation
    Purpose: Brief description
    Business Logic: Key transformations
    Dependencies: Source tables/models
*/

WITH cte_name AS (
    -- Clear CTE logic
    SELECT ...
),

final AS (
    SELECT ...
)

SELECT * FROM final
```

## Specific Transformation Guidance

### BTEQ Control Flow â†’ DBT Patterns
- Convert DELETE + INSERT patterns to proper materialization
- Replace BTEQ variables with DBT vars and Jinja variables
- Transform error handling to DBT test patterns where possible
- Convert procedural logic to declarative SQL transformations

### Date/Time Functions
- Use DBT date functions or modern SQL equivalents
- Replace Teradata date arithmetic with standard functions
- Maintain timezone handling if present

### Process Control Tables
- Reference process control via source() or ref() macros
- Use var() for process configuration values
- Implement delta processing via incremental materialization

## Output Instructions

Provide ONLY the complete DBT model SQL code. Do not include explanations, markdown formatting, or additional commentary.

## DBT Model: